{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BuildingBlocks \ud83e\udde9","text":"<p>Composable abstractions for clean, testable, and maintainable Python architectures.</p> <p>Start here to learn how to design framework-agnostic systems using clear boundaries and contracts.</p> <ul> <li>Getting Started</li> <li>Architecture Overview</li> <li>Packages &amp; Layers</li> <li>Reference Index</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>Guidelines for contributing to the BuildingBlocks project.</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p>"},{"location":"test_mermaid/","title":"My Page with a Diagram","text":"<p>A simple flowchart illustrating a decision process:</p> <pre><code>graph TD\n    A[Start Process] --&gt; B{Is it working?};\n    B --&gt;|Yes| C[Do next step];\n    B --&gt;|No| D[Troubleshoot];\n    C --&gt; E[End];\n    D --&gt; B;\n</code></pre>"},{"location":"guide/","title":"Guide \ud83e\udded","text":"<p>Audience: Application developers using BuildingBlocks to design clean, testable, and maintainable systems.</p> <p>Welcome to the BuildingBlocks Guide.</p> <p>This section introduces the core ideas, architectural principles, and conventions used throughout the toolkit.</p> <p>It explains how to apply BuildingBlocks in your own projects, covering concepts like layering, ports and adapters, result handling, and testing practices.</p> <p>If you're learning how to use BuildingBlocks --- this is your starting point.</p>"},{"location":"guide/#contents","title":"\ud83d\udcda Contents","text":"<ul> <li>Getting Started</li> <li>Architecture Guide</li> <li>Principles</li> <li>Packages &amp; Layers</li> <li>Examples</li> <li>Example Tests</li> <li>Testing</li> </ul>"},{"location":"guide/architecture/","title":"Architecture Guide \ud83e\udde0","text":"<p>The BuildingBlocks toolkit follows a composable architecture model based on clear boundaries, contracts, and abstractions.</p> <p>It enables developers to design systems that are testable, maintainable, and framework-agnostic.</p>"},{"location":"guide/architecture/#core-idea","title":"\ud83e\udde9 Core Idea","text":"<p>\u201cArchitecture is about intent \u2014 code is about implementation.\u201d</p> <p>BuildingBlocks helps you express intent explicitly through interfaces (Ports) and domain-driven abstractions (Entities, Value Objects, Events).</p> <p>This approach supports Clean Architecture, Hexagonal Architecture, and DDD, without enforcing any strict style.</p>"},{"location":"guide/architecture/#layers-overview","title":"\ud83e\udde0 Layers Overview","text":"Layer Responsibility Depends On Foundation Defines core abstractions like <code>Result</code>, <code>Port</code>, and <code>Mapper</code> None Domain Encapsulates business rules and domain logic Foundation Application Coordinates domain behavior via use cases and ports Domain, Foundation Infrastructure Implements adapters for persistence, events, and I/O Application, Domain Presentation Exposes entry points (API, CLI, etc.) Application <pre><code>graph TD\n    A[Presentation Layer] --&gt;|Invokes| B[Application Layer]\n    B --&gt;|Uses| C[Domain Layer]\n    C --&gt;|Depends on| D[Foundation Layer]\n    B --&gt;|Delegates to| E[Infrastructure Layer]\n    style A fill:#2a2a2a,stroke:#555,stroke-width:2px,color:#fff\n    style B fill:#333,stroke:#555,stroke-width:2px,color:#fff\n    style C fill:#444,stroke:#555,stroke-width:2px,color:#fff\n    style D fill:#555,stroke:#777,stroke-width:2px,color:#fff\n    style E fill:#222,stroke:#666,stroke-width:2px,color:#fff\n</code></pre>"},{"location":"guide/architecture/#design-principles","title":"\ud83e\uddf1 Design Principles","text":""},{"location":"guide/architecture/#1-explicit-boundaries","title":"1. Explicit Boundaries","text":"<p>Each layer exposes only what it must and depends only on contracts, not implementations.</p>"},{"location":"guide/architecture/#2-dependency-inversion","title":"2. Dependency Inversion","text":"<p>High-level modules (domain and application) define interfaces.</p> <p>Low-level modules (infrastructure, presentation) implement them.</p>"},{"location":"guide/architecture/#3-immutability","title":"3. Immutability","text":"<p>Entities and Value Objects are immutable by default, ensuring consistency and safe concurrency.</p>"},{"location":"guide/architecture/#4-composability","title":"4. Composability","text":"<p>All abstractions (e.g., <code>Result</code>, <code>Port</code>, <code>Mapper</code>) can be reused and composed without framework dependencies.</p>"},{"location":"guide/architecture/#flow-example","title":"\ud83e\udde9 Flow Example","text":"<ol> <li> <p>Presentation Layer receives a command or query.</p> </li> <li> <p>It invokes an Application Use Case through an Inbound Port.</p> </li> <li> <p>The Use Case interacts with Domain Entities and Value Objects.</p> </li> <li> <p>It delegates to Outbound Ports implemented by the Infrastructure Layer.</p> </li> <li> <p>Results flow back as explicit <code>Result</code> objects (<code>Ok</code> / <code>Err</code>).</p> </li> </ol> <pre><code>flowchart LR\n    subgraph UserInterface[Presentation Layer]\n        A[User / API Request]\n    end\n    subgraph App[Application Layer]\n        B[Use Case]\n        C[Inbound Port]\n        D[Outbound Port]\n    end\n    subgraph Domain[Domain Layer]\n        E[Entities / Value Objects]\n    end\n    subgraph Infra[Infrastructure Layer]\n        F[(Database / Broker / External System)]\n    end\n\n    A --&gt;|Command| B\n    B --&gt; C\n    B --&gt;|Invokes| E\n    B --&gt;|Calls| D\n    D --&gt;|Implemented by| F\n    F --&gt;|Returns Result| B\n    B --&gt;|Ok/Err| A\n</code></pre>"},{"location":"guide/architecture/#recommended-reading","title":"\u2699\ufe0f Recommended Reading","text":"<ul> <li>Clean Architecture \u2014 Robert C. Martin</li> <li>Implementing Domain-Driven Design \u2014 Vaughn Vernon</li> <li>Patterns of Enterprise Application Architecture \u2014 Martin Fowler</li> <li>Get Your Hands Dirty on Clean Architecture \u2014 Tom Hombergs</li> </ul>"},{"location":"guide/architecture/#summary","title":"\u2705 Summary","text":"<p>BuildingBlocks is not a framework \u2014 it\u2019s a foundation.</p> <p>It helps you express intent, isolate concerns, and design systems that evolve gracefully.</p>"},{"location":"guide/example_tests/","title":"Example Tests \ud83e\udde9","text":"<p>For developers using BuildingBlocks this guide shows how to write tests for each layer.</p> <p>It complements the conceptual Testing Strategy page.</p>"},{"location":"guide/example_tests/#domain-example","title":"\ud83e\uddf1 Domain Example","text":"<p>Your tests should be written against your domain models to verify their behavior.</p> <p>Entity methods represents domain logic and should be testedin any possible scenario that may arise.</p> <pre><code>from __future__ import annotations\n\nfrom uuid import UUID\n\nfrom building_blocks.domain import Entity\n\nclass User(Entity[UUID]):\n    id: UUID\n    name: str\n\n    @classmethod\n    def register(cls, id: int, name: str) -&gt; User:\n        return cls(id=id, name=name)\n\nclass TestUser:\n    def test_register_when_called_2_times_same_names_but_different_id(self) -&gt; None:\n        # Arrange\n        actual_name = \"Alice\"\n\n        # Act\n        created_user_a = User.register(name=actual_name)\n        created_user_b = User.register(name=actual_name)\n\n        # Assert\n        expected_name = actual_name\n        assert created_user_a.name == expected_name\n        assert created_user_b.name == expected_name\n        assert created_user_a.id != created_user_b.id\n</code></pre>"},{"location":"guide/example_tests/#application-example-use-case","title":"\u2699\ufe0f Application Example --- Use Case","text":"<pre><code>from dataclasses import dataclass\n\nfrom building_blocks.application import UseCase\nfrom building_blocks.foundation import Error, Ok, Err, Result\n\n@dataclass(frozen=True)\nclass DivideNumbersRequest:\n    dividend: int\n    divisor: int\n\n@dataclass(frozen=True)\nclass DivideNumbersResponse:\n    quotient: int\n\nclass DivideNumbersError(Error):\n    reason: str\n\nDivideNumbersResult = Result[DivideNumbersResponse, DivideNumbersError]\n\nclass DivideNumbersUseCase(UseCase[DivideNumbersRequest, DivideNumbersResult]):\n    def execute(self, request: DivideNumbersRequest) -&gt; DivideNumbersResult:\n        a, b = request.dividend, request.divisor\n        if b == 0:\n            return Err(DivideNumbersError(\"division by zero\"))\n        return Ok(DivideNumbersResponse(a // b))\n\nclass TestDivideNumbersUseCase:\n    def test_execute_when_divisor_is_zero_then_division_by_zero_error(self) -&gt; None:\n        dividend = 10\n        divisor = 0\n        request = DivideNumbersRequest(dividend, divisor)\n        use_case = DivideNumbersUseCase()\n\n        result = use_case.execute(request)\n\n        expected_reason = \"division by zero\"\n        expected_is_err = True\n        assert result.is_err() == expected_is_err\n        assert result.error.reason == expected_reason\n\n    def test_execute_when_dividend_is_10_and_divisor_is_5_then_2(self) -&gt; None:\n        dividend = 10\n        divisor = 5\n        request = DivideNumbersRequest(dividend, divisor)\n        use_case = DivideNumbersUseCase()\n\n        result = use_case.execute(request)\n\n        expected_quotient = 2\n        assert result.is_ok()\n        assert result.value.quotient == expected_quotient\n</code></pre>"},{"location":"guide/example_tests/#infrastructure-example-repository-adapter","title":"\ud83e\udde9 Infrastructure Example --- Repository Adapter","text":"<pre><code>from building_blocks.application import Repository\nfrom building_blocks.domain import Entity\n\nclass User(Entity):\n    id: int\n    name: str\n\nclass InMemoryUserRepository(Repository[User]):\n    def __init__(self, data: dict[int, User]) -&gt; None:\n        self._data = data\n\n    async def delete_by_id(self, user_id: int) -&gt; None:\n        self._data.pop(user_id, None)\n\n    async def get_by_id(self, user_id: int) -&gt; User | None:\n        return self._data.get(user_id)\n\n    async def list_all(self) -&gt; list[User]:\n        return list(self._data.values())\n\n    async def save(self, user: User) -&gt; None:\n        self._data[user.id] = user\n\nclass TestInMemoryUserRepository:\n    async def test_save_when_user_is_added_then_persist_data_source(self) -&gt; None:\n        data = {}\n        user = User(id=1, name=\"Alice\")\n        repo = InMemoryUserRepository(data)\n\n        await repo.save(user)\n\n        persisted_user = data.get(1)\n        assert retrieved_user == user\n</code></pre> <p>Continue exploring the Testing Strategy page for the underlying principles behind these examples.</p>"},{"location":"guide/examples/","title":"Architecture Examples \ud83e\udde9","text":"<p>This section illustrates how to apply BuildingBlocks in different contexts and architectural styles.</p>"},{"location":"guide/examples/#example-1-clean-architecture-typical-web-app","title":"\u26a1 Example 1 \u2014 Clean Architecture (Typical Web App)","text":"<pre><code>flowchart TD\n    A[HTTP Request] --&gt; B[Controller]\n    B --&gt; C[Use Case]\n    C --&gt; D[Domain Entity]\n    C --&gt; E[Repository Port]\n    E --&gt; F[Infrastructure Adapter]\n    F --&gt; G[(Database)]\n</code></pre>"},{"location":"guide/examples/#flow","title":"Flow","text":"<ol> <li>The controller receives a request and creates a command.</li> <li>The application use case executes it through an inbound port.</li> <li>The use case manipulates domain entities.</li> <li>It calls outbound ports (repositories, buses).</li> <li>The infrastructure layer fulfills those ports.</li> </ol>"},{"location":"guide/examples/#example-2-event-driven-architecture","title":"\u2699\ufe0f Example 2 \u2014 Event-Driven Architecture","text":"<pre><code>sequenceDiagram\n    participant Domain as Domain Layer\n    participant App as Application Layer\n    participant Bus as EventBus (Infrastructure)\n    participant External as External Service\n\n    Domain-&gt;&gt;App: Publish DomainEvent\n    App-&gt;&gt;Bus: EventHandler sends event\n    Bus-&gt;&gt;External: Notify via message broker\n</code></pre> <p>Events decouple the system, allowing asynchronous workflows and CQRS-style read models.</p>"},{"location":"guide/examples/#example-3-cqrs","title":"\ud83e\udde9 Example 3 \u2014 CQRS","text":"<pre><code>flowchart LR\n    A[Command] --&gt; B[CommandHandler]\n    B --&gt; C[AggregateRoot]\n    C --&gt; D[EventBus]\n    D --&gt; E[QueryHandler]\n    E --&gt; F[(Read Model)]\n</code></pre> <p>The command side updates aggregates and emits events.</p> <p>The query side responds to read requests with dedicated data models.</p>"},{"location":"guide/examples/#example-4-using-ports-and-adapters","title":"\ud83e\uddf1 Example 4 \u2014 Using Ports and Adapters","text":"<pre><code># inbound port\nclass RegisterUserUseCase(UseCase[RegisterUserInput, Result[User, Error]]):\n    ...\n\n# outbound port\nclass UserRepository(Repository[User]):\n    ...\n\n# infrastructure adapter\nclass SqlUserRepository(UserRepository):\n    ...\n</code></pre>"},{"location":"guide/examples/#summary","title":"\u2705 Summary","text":"<p>These examples show that BuildingBlocks does not dictate the architecture \u2014 it enables composition across many styles (Clean, Hexagonal, CQRS, SOA, etc.).</p>"},{"location":"guide/getting-started/","title":"Getting Started \ud83d\ude80","text":"<p>Welcome to BuildingBlocks \u2014 a toolkit to help you write clean, testable, and maintainable Python code.</p>"},{"location":"guide/getting-started/#installation","title":"\ud83d\udce6 Installation","text":"<p>You can install it via Poetry</p> <pre><code>poetry add building-blocks\n</code></pre> <p>Using pip</p> <pre><code>\npip install building-blocks\n</code></pre> <p>Using UV</p> <pre><code>uv install building-blocks\n</code></pre> <p>or any tool that supports PyPI packages.</p>"},{"location":"guide/getting-started/#quick-example","title":"\ud83e\udde9 Quick Example","text":"<pre><code>from building_blocks.foundation import Result, Ok, Err\n\ndef divide(a: int, b: int) -&gt; Result[int, str]:\n    if b == 0:\n        return Err(\"division by zero\")\n    return Ok(a // b)\n\nresult = divide(10, 2)\nif result.is_ok():\n    print(result.value)  # \u2192 5\n</code></pre>"},{"location":"guide/getting-started/#why-use-buildingblocks","title":"\ud83e\udde0 Why Use BuildingBlocks?","text":"<p>Most Python codebases grow messy because boundaries are not explicit.</p> <p>BuildingBlocks provides abstractions that make intent and responsibility clear and help you to write decoupled applications.</p> <p>You can use it to:</p> <ul> <li>Improve code organization</li> <li>Enhance testability</li> <li>Facilitate maintenance and evolution</li> <li>Teach architecture principles</li> <li>Structure new projects with clear layers</li> <li>Build layered systems (Clean, Hexagonal, DDD, CQRS, etc.)</li> <li>Experiment with architecture concepts safely</li> <li>Learn decoupling, ports/adapters, and type-safe composition</li> </ul>"},{"location":"guide/getting-started/#the-core-components","title":"\ud83e\uddf1 The Core Components","text":"Component Role Foundation Core utilities (<code>Result</code>, <code>Port</code>, <code>Mapper</code>) that compose the layers below. It is not an architectural layer. Domain The heart of the system; contains the business rules and domain models (<code>AggregateRoot</code>, <code>Entity</code>, <code>ValueObject</code>). Application Defines the use cases ports (e.g., <code>CreateUser</code>, <code>ProcessOrder</code>), implement them and orchestrates domain logic. Infrastructure Adapters for external concerns (Databases, APIs, Emailing, File Systems). Presentation The entry points to your system (REST API endpoints, CLI commands, Message Queue listeners)."},{"location":"guide/getting-started/#next-steps","title":"\ud83e\udded Next Steps","text":"<ul> <li>Read the Architecture Guide</li> <li>Explore Packages &amp; Layers</li> <li>Check the Reference</li> </ul>"},{"location":"guide/packages_and_layers/","title":"Packages and Layers \ud83e\udde9","text":"<p>BuildingBlocks organizes your code into layered packages that make large systems easier to reason about, test, and extend.</p> <p>Each package has a clear responsibility and communicates with others through explicit boundaries (Ports).</p>"},{"location":"guide/packages_and_layers/#the-big-picture","title":"\ud83e\uddf1 The Big Picture","text":"<p>\u201cGood architecture is about knowing where things belong.\u201d</p> <p>BuildingBlocks follows a layered architecture model:</p> <ul> <li>each package represents a boundary of responsibility.</li> </ul> <pre><code>graph TD\n    A[Presentation Layer] --&gt;|Invokes| B[Application Layer]\n    B --&gt;|Uses| C[Domain Layer]\n    C --&gt;|Depends on| D[Foundation Layer]\n    B --&gt;|Delegates to| E[Infrastructure Layer]\n    style A fill:#2a2a2a,stroke:#555,color:#fff\n    style B fill:#333,stroke:#555,color:#fff\n    style C fill:#444,stroke:#555,color:#fff\n    style D fill:#555,stroke:#777,color:#fff\n    style E fill:#222,stroke:#666,color:#fff\n</code></pre>"},{"location":"guide/packages_and_layers/#packages-overview","title":"\ud83d\udce6 Packages Overview","text":"Package Responsibility Depends On <code>foundation</code> Core abstractions (<code>Result</code>, <code>Port</code>, <code>Mapper</code>) None <code>domain</code> Business rules, Entities, Value Objects, Domain Events Foundation <code>application</code> Use cases and orchestration logic Domain, Foundation <code>infrastructure</code> Technical adapters (DB, message brokers, APIs) Application, Domain <code>presentation</code> Entry points (API, CLI, UI) Application"},{"location":"guide/packages_and_layers/#packages-in-detail","title":"\ud83e\udde9 Packages in Detail","text":""},{"location":"guide/packages_and_layers/#1-foundation-package","title":"1. Foundation Package","text":"<p>Purpose:</p> <p>Defines reusable, layer-agnostic abstractions that enforce consistency and composability.</p> <p>Includes:</p> <ul> <li><code>Result</code>, <code>Ok</code>, <code>Err</code> \u2192 explicit success/failure semantics</li> <li><code>Port</code>, <code>InboundPort</code>, <code>OutboundPort</code> \u2192 define boundaries</li> <li><code>Mapper</code> \u2192 safe data transformations</li> <li><code>Immutable</code> \u2192 enforce immutability for Entities and Value Objects</li> </ul> <p>Usage:</p> <p>Imported by all other layers; has no dependencies on any domain logic.</p> <pre><code>graph TD\n    A[Foundation] --&gt; B[Domain]\n    A --&gt; C[Application]\n    C --&gt; D[Infrastructure]\n    C --&gt; E[Presentation]\n</code></pre>"},{"location":"guide/packages_and_layers/#2-domain-package","title":"2. Domain Package","text":"<p>Purpose:</p> <p>Encapsulates the business rules and ubiquitous language of your system.</p> <p>Includes:</p> <ul> <li><code>Entity</code> \u2014 uniquely identifiable object</li> <li><code>ValueObject</code> \u2014 equality by value</li> <li><code>AggregateRoot</code> \u2014 transactional boundary</li> <li><code>DomainEvent</code> \u2014 explicit business occurrences</li> </ul> <p>Usage:</p> <p>Pure logic, no infrastructure dependencies.</p> <p>This is the heart of the system \u2014 everything else exists to support it.</p>"},{"location":"guide/packages_and_layers/#3-application-package","title":"3. Application Package","text":"<p>Purpose:</p> <p>Coordinates behavior between the Domain and the outside world using ports and services.</p> <p>Includes:</p> <ul> <li>Inbound Ports \u2014 define use cases (<code>RegisterUserUseCase</code>, <code>ProcessOrderUseCase</code>)</li> <li>Outbound Ports \u2014 define external dependencies (<code>Repository</code>, <code>EventPublisher</code>, <code>MessageBus</code>)</li> <li>Services \u2014 orchestrate domain logic via these ports</li> </ul> <p>Usage:</p> <ul> <li>Implements business processes, not business rules.</li> <li>No direct database, HTTP, or framework code \u2014 only contracts.</li> </ul> <pre><code>graph TD\n    subgraph Application\n        A[Inbound Port / UseCase]\n        B[Outbound Port]\n    end\n    subgraph Domain\n        D[Entities / ValueObjects]\n    end\n    subgraph Infrastructure\n        E[(Adapters)]\n    end\n    A --&gt; D\n    D --&gt; B\n    B --&gt; E\n</code></pre>"},{"location":"guide/packages_and_layers/#4-infrastructure-package","title":"4. Infrastructure Package","text":"<p>Purpose:</p> <p>Implements the technical details that fulfill the application\u2019s outbound contracts.</p> <p>Includes:</p> <ul> <li>Repository adapters (SQLAlchemy, Mongo, In-Memory)</li> <li>Message/Event Bus implementations (RabbitMQ, Redis, etc.)</li> <li>External API clients and persistence layers</li> </ul> <p>Usage:</p> <p>Provides real implementations for the abstract ports defined in the application layer. You can replace or mock these components without changing your core logic.</p>"},{"location":"guide/packages_and_layers/#5-presentation-package","title":"5. Presentation Package","text":"<p>Purpose:</p> <p>Handles all inbound interactions \u2014 user requests, CLI commands, or external events.</p> <p>Includes:</p> <ul> <li>REST or GraphQL controllers (FastAPI, Django, etc.)</li> <li>CLI interfaces (Click, Typer)</li> <li>Event consumers (Kafka, RabbitMQ listeners)</li> </ul> <p>Usage:</p> <p>Translates external inputs into commands or queries sent to the application layer.</p>"},{"location":"guide/packages_and_layers/#documentation-convention","title":"\ud83e\uddf1 Documentation Convention","text":"<p>To keep your docs and code consistent:</p> Term Meaning Example Package A directory with <code>__init__.py</code> representing a namespace or layer <code>foundation/</code>, <code>domain/</code>, <code>application/</code> Module A single <code>.py</code> file implementing one concept <code>foundation/result.py</code> \u2192 Result module <p>Use \u201cpackage\u201d for architectural boundaries and \u201cmodule\u201d for individual building blocks.</p>"},{"location":"guide/packages_and_layers/#why-it-matters","title":"\ud83e\udde0 Why It Matters?","text":"<ul> <li>Encourages isolation \u2014 layers evolve independently.</li> <li>Simplifies testing \u2014 test behavior per layer.</li> <li>Promotes clarity \u2014 intent and dependencies are visible.</li> <li>Supports teaching \u2014 concepts are self-contained and discoverable.</li> </ul>"},{"location":"guide/packages_and_layers/#summary-rule","title":"\u2705 Summary Rule","text":"<p>Package = boundary of responsibility</p> <p>Module = reusable building block inside a package</p> <p>Together, they make your architecture composable, testable, and teachable \u2014 one layer at a time.</p>"},{"location":"guide/principles/","title":"Architectural Principles \ud83e\udded","text":"<p>BuildingBlocks is grounded in timeless software design principles that make systems robust, adaptable, and maintainable.</p>"},{"location":"guide/principles/#1-separation-of-concerns","title":"\ud83e\udde9 1. Separation of Concerns","text":"<p>Each layer in the architecture has a distinct purpose:</p> <ul> <li>Foundation \u2014 core abstractions, no dependencies.</li> <li>Domain \u2014 pure business rules.</li> <li>Application \u2014 orchestration and coordination logic.</li> <li>Infrastructure \u2014 external integrations and persistence.</li> <li>Presentation \u2014 entry points and delivery mechanisms.</li> </ul> <p>This separation avoids coupling between technical and business concerns.</p>"},{"location":"guide/principles/#2-dependency-inversion-principle-dip","title":"\ud83e\uddf1 2. Dependency Inversion Principle (DIP)","text":"<p>High-level modules (domain, application) define interfaces (Ports).</p> <p>Low-level modules (infrastructure, presentation) implement those interfaces.</p> <p>\u201cDepend on abstractions, not on concretions.\u201d \u2014 Robert C. Martin</p>"},{"location":"guide/principles/#3-explicit-boundaries","title":"\ud83d\udd04 3. Explicit Boundaries","text":"<p>Every dependency is made explicit through ports or contracts.</p> <p>You always know what a layer depends on \u2014 there are no hidden side effects.</p>"},{"location":"guide/principles/#4-immutability-and-safety","title":"\ud83e\udde0 4. Immutability and Safety","text":"<p>Entities and Value Objects are immutable by default, ensuring that business rules cannot be violated through uncontrolled mutations.</p>"},{"location":"guide/principles/#5-composability","title":"\u2699\ufe0f 5. Composability","text":"<p>Everything in BuildingBlocks can be combined like LEGO pieces:</p> <p>each class, protocol, and helper is small, explicit, and self-contained.</p>"},{"location":"guide/principles/#6-testability","title":"\ud83e\uddea 6. Testability","text":"<p>Because boundaries are explicit, layers can be tested in isolation.</p> <p>Mocking or substituting ports becomes trivial.</p>"},{"location":"guide/principles/#7-framework-independence","title":"\ud83c\udfd7\ufe0f 7. Framework Independence","text":"<p>BuildingBlocks does not force you into a specific runtime or web framework.</p> <p>You can use it with FastAPI, Django, Flask, Click, or even plain scripts \u2014 the design remains consistent.</p>"},{"location":"guide/principles/#summary","title":"\u2705 Summary","text":"<p>BuildingBlocks promotes intentional design:</p> <ul> <li>Each boundary is explicit.</li> <li>Each dependency is visible.</li> <li>Each decision is reversible.</li> </ul>"},{"location":"guide/testing/","title":"Testing \ud83e\uddea","text":"<p>For a hands-on look at real test examples for each layer, see Example Tests.</p> <p>The BuildingBlocks toolkit encourages a testing strategy that mirrors its architecture.\\ Each layer --- from Foundation to Infrastructure --- can be tested independently using predictable patterns and explicit contracts.</p>"},{"location":"guide/testing/#domain-layer","title":"\ud83e\uddf1 Domain Layer","text":"<ul> <li>Test pure business logic with no external dependencies.</li> <li>Use value objects, entities, and aggregates in     isolation.</li> <li>Validate invariants, rules, and domain events.</li> </ul> <p>Domain tests should not depend on frameworks or infrastructure.</p>"},{"location":"guide/testing/#application-layer","title":"\u2699\ufe0f Application Layer","text":"<ul> <li>Test use cases through their inbound ports (interfaces).</li> <li>Mock outbound dependencies such as repositories or event buses.</li> <li>Validate that each use case produces the expected Result type     (Ok/Err).</li> </ul> <p>Application tests focus on orchestration --- not persistence.</p>"},{"location":"guide/testing/#infrastructure-layer","title":"\ud83e\udde9 Infrastructure Layer","text":"<ul> <li>Test adapters (repositories, event publishers, message buses).</li> <li>Use in-memory or temporary database fixtures when     appropriate.</li> <li>Verify correctness of integration with external systems.</li> </ul> <p>Keep infrastructure tests focused on technical boundaries.</p>"},{"location":"guide/testing/#general-guidelines","title":"\ud83e\udde0 General Guidelines","text":"<ul> <li>Follow the AAA pattern (Arrange \u2192 Act \u2192 Assert).</li> <li>Use pytest fixtures for clean, reusable setup.</li> <li>Prefer behavioral assertions (what the code does) over     structural ones (how it does it).</li> <li>Each test name should clearly express intent using:\\     <code>test_&lt;method&gt;_WHEN_&lt;scenario&gt;_THEN_&lt;expected_result&gt;</code></li> </ul> <p>Testing in BuildingBlocks is about clarity and intent --- ensuring that each layer is verified independently, without leaking concerns across architectural boundaries.</p>"},{"location":"reference/","title":"Reference \ud83d\udcd6","text":"<p>Audience: Contributors and maintainers of BuildingBlocks who want to understand its internal design, structure, and abstractions.</p> <p>The Reference section documents the internal components of BuildingBlocks --- what each package contains, how they depend on one another, and how they fit into the overall architecture.</p> <p>It is primarily useful for developers extending or improving the toolkit itself.</p>"},{"location":"reference/#package-overview","title":"\ud83e\udde9 Package Overview","text":"<p>Package                       Description</p> <p>Foundation                Core abstractions (<code>Result</code>, <code>Port</code>,                                 <code>Mapper</code>) shared across all layers</p> <p>Domain                    Encapsulates business rules and the                                 ubiquitous language</p> <p>Application               Defines use cases and application logic                                 through inbound and outbound ports</p> <p>Infrastructure            Implements adapters for external systems                                 (e.g., databases, events, APIs)</p> <p>Presentation              Provides entry points (HTTP API, CLI, or                                 message consumers)</p>"},{"location":"reference/#contents","title":"\ud83d\udcda Contents","text":"<ul> <li>Foundation</li> <li>Domain</li> <li>Application</li> <li>Infrastructure</li> <li>Presentation</li> <li>Example Tests</li> </ul>"},{"location":"reference/application/","title":"Application Package \u2699\ufe0f","text":"<p>The application package defines how the system behaves \u2014 it orchestrates domain logic through inbound and outbound ports.</p>"},{"location":"reference/application/#purpose","title":"\ud83e\udde0 Purpose","text":"<p>This layer expresses what the system does \u2014 coordinating the domain with the outside world through explicit boundaries.</p> <ul> <li>Inbound Ports define use cases (entry points).  </li> <li>Outbound Ports define dependencies (repositories, message buses, etc.).</li> </ul>"},{"location":"reference/application/#structure","title":"\ud83e\udde9 Structure","text":"<pre><code>application/\n\u251c\u2500\u2500 ports/\n\u2502   \u251c\u2500\u2500 inbound/\n\u2502   \u2502   \u251c\u2500\u2500 &lt;action&gt;_use_case.py\n\u2502   \u2502   \u2514\u2500\u2500 &lt;action&gt;_service.py\n\u2502   \u2514\u2500\u2500 outbound/\n\u2502       \u251c\u2500\u2500 &lt;entity&gt;_repository.py\n\u2502       \u251c\u2500\u2500 event_publisher.py\n\u2502       \u251c\u2500\u2500 command_sender.py\n\u2502       \u251c\u2500\u2500 query_fetcher.py\n\u2502       \u2514\u2500\u2500 message_bus.py\n\u2514\u2500\u2500 services/\n</code></pre>"},{"location":"reference/application/#inbound-ports","title":"\u2699\ufe0f Inbound Ports","text":"<p>Inbound ports define use cases (application entry points).</p> <p>Each <code>&lt;action&gt;_use_case.py</code> file defines a protocol for a specific action.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Protocol\nfrom building_blocks.application import UseCase\nfrom building_blocks.foundation import Result\n\n@dataclass(frozen=True)\nclass RegisterUserRequest:\n    '''Request DTO containing data required to register a new user.'''\n    username: str\n    email: str\n    password: str\n\n@dataclass(frozen=True)\nclass RegisterUserResponse:\n    '''Response DTO containing the ID of the created user.'''\n    user_id: str\n\n@dataclass(frozen=True)\nclass RegisterUserError:\n    '''Represents a failure reason during user registration.'''\n    reason: str\n\nRegisterUserResult = Result[RegisterUserResponse, RegisterUserError]\n\nclass RegisterUserUseCase(UseCase[RegisterUserRequest, RegisterUserResult], Protocol):\n    '''Inbound port representing the \"Register User\" use case.'''\n    async def execute(self, request: RegisterUserRequest) -&gt; RegisterUserResult:\n        '''Executes the registration logic.\n        Args:\n            request: The user registration data.\n        Returns:\n            A `Result` containing the created user ID or an error.\n        '''\n        ...\n</code></pre>"},{"location":"reference/domain/","title":"Domain Package \ud83c\udfdb\ufe0f","text":"<p>The domain package defines the core business rules and ubiquitous language of your system. It expresses what the system is \u2014 not what it does.</p>"},{"location":"reference/domain/#purpose","title":"\ud83e\udde9 Purpose","text":"<p>The domain layer is the heart of your application. It models behavior through Entities, Value Objects, and Aggregate Roots.</p>"},{"location":"reference/domain/#core-components","title":"\u2699\ufe0f Core Components","text":""},{"location":"reference/domain/#valueobject","title":"ValueObject","text":"<p>An immutable object defined by its attributes, not identity.</p> <pre><code>class Coordinate(ValueObject):\n    x: float\n    y: float\n</code></pre>"},{"location":"reference/domain/#entity","title":"Entity","text":"<p>An object with a unique identity that encapsulates behavior and state.</p> <pre><code>class User(Entity):\n    id: UUID\n    name: str\n</code></pre>"},{"location":"reference/domain/#aggregateroot","title":"AggregateRoot","text":"<p>A cluster of entities treated as a single unit of consistency.</p> <pre><code>class Order(AggregateRoot):\n    id: UUID\n    items: list[OrderItem]\n\n    def add_item(self, item: OrderItem) -&gt; None:\n        self.items.append(item)\n</code></pre>"},{"location":"reference/domain/#diagram","title":"\ud83e\udde9 Diagram","text":"<pre><code>graph TD\n    A[Entity] --&gt; B[AggregateRoot]\n    B --&gt; C[DomainEvent]\n    A --&gt; D[ValueObject]\n</code></pre>"},{"location":"reference/domain/#cross-links","title":"\ud83e\udded Cross-links","text":"<ul> <li>See also: Application Layer \u2014 orchestrates domain operations.</li> <li>See also: Foundation Layer \u2014 provides base contracts like <code>Result</code> and <code>Port</code>.</li> </ul>"},{"location":"reference/domain/#summary","title":"\u2705 Summary","text":"Aspect Description Responsibility Express and enforce business rules Depends on Foundation Used by Application, Infrastructure Should not depend on Infrastructure, Presentation"},{"location":"reference/foundation/","title":"Foundation Package \ud83e\udde9","text":"<p>The foundation package defines the core abstractions that the rest of the toolkit depends on.</p> <p>It provides reusable contracts \u2014 small, composable building blocks that enforce clarity and explicit boundaries.</p>"},{"location":"reference/foundation/#purpose","title":"\ud83e\udde0 Purpose","text":"<p>The foundation layer defines layer-agnostic interfaces and helpers that can be reused anywhere.</p> <p>It contains no business logic or framework dependencies.</p>"},{"location":"reference/foundation/#components","title":"\u2699\ufe0f Components","text":""},{"location":"reference/foundation/#result","title":"Result","text":"<p>Represents success or failure explicitly without exceptions.</p> <pre><code>from building_blocks.foundation import Result, Ok, Err\n\ndef divide(a: int, b: int) -&gt; Result[int, str]:\n    if b == 0:\n        return Err(\"division by zero\")\n    return Ok(a // b)\n</code></pre>"},{"location":"reference/foundation/#port","title":"Port","text":"<p>The base abstraction for communication boundaries between layers.</p> <pre><code>class Port(Generic[InputType, OutputType], Protocol):\n    def execute(self, data: InputType) -&gt; OutputType:\n        ...\n</code></pre> <p>You can use as a marker for inbound and outbound ports.</p>"},{"location":"reference/foundation/#inboundport","title":"InboundPort","text":"<p>Marker for application entry points.</p> <pre><code>class InboundPort(Port[InputType, OutputType], Protocol):\n    ...\n</code></pre>"},{"location":"reference/foundation/#outboundport","title":"OutboundPort","text":"<p>Marker for application dependencies.</p> <pre><code>class OutboundPort(Port[InputType, OutputType], Protocol):\n    ...\n</code></pre>"},{"location":"reference/foundation/#mapper","title":"Mapper","text":"<p>Defines safe type transformations between layers.</p> <pre><code>class Mapper(Generic[SourceType, TargetType], Protocol):\n    def map(self, source: SourceType) -&gt; TargetType:\n        ...\n</code></pre>"},{"location":"reference/foundation/#event-bus","title":"Event Bus","text":"<p>Defines contracts for publishing and handling events.</p>"},{"location":"reference/foundation/#immutable","title":"Immutable","text":"<p>Mixin and decorators that make entities and value objects immutable.</p>"},{"location":"reference/foundation/#cross-links","title":"\ud83e\udded Cross-links","text":"<ul> <li>See also: Domain Layer for business rules.</li> <li>See also: Application Layer for orchestration logic.</li> </ul>"},{"location":"reference/foundation/#diagram","title":"\ud83e\udde9 Diagram","text":"<pre><code>graph TD\n    A[Foundation] --&gt; B[Domain]\n    A --&gt; C[Application]\n    C --&gt; D[Infrastructure]\n    C --&gt; E[Presentation]\n</code></pre>"},{"location":"reference/foundation/#summary","title":"\u2705 Summary","text":"Aspect Description Responsibility Define reusable abstractions and contracts Depends on None Used by All layers Should not depend on Domain, Application, Infrastructure, Presentation"},{"location":"reference/infrastructure/","title":"Infrastructure Package \ud83c\udfd7\ufe0f","text":"<p>The infrastructure package contains technical implementations of outbound ports defined in the application layer.</p>"},{"location":"reference/infrastructure/#purpose","title":"\ud83e\udde0 Purpose","text":"<p>Implements adapters that connect the application to external systems such as databases, APIs, and message brokers.</p>"},{"location":"reference/infrastructure/#components","title":"\u2699\ufe0f Components","text":""},{"location":"reference/infrastructure/#repository-implementations","title":"Repository Implementations","text":"<pre><code>class SqlUserRepository(UserRepository):\n    '''SQL-based implementation of the UserRepository outbound port.'''\n    async def save(self, user: User) -&gt; None:\n        '''Persist a user to the database.'''\n        await db.execute(\"INSERT INTO users (id, username, email) VALUES (:id, :username, :email)\", user.to_dict())\n</code></pre>"},{"location":"reference/presentation/","title":"Presentation Package \ud83e\udde9","text":"<p>The presentation package is the system\u2019s entry point. It handles user or system interactions and delegates execution to the application layer.</p>"},{"location":"reference/presentation/#purpose","title":"\ud83e\udde0 Purpose","text":"<p>Implements inbound adapters such as APIs, CLI commands, or event consumers.</p>"},{"location":"reference/presentation/#components","title":"\u2699\ufe0f Components","text":""},{"location":"reference/presentation/#rest-api-controllers","title":"REST API Controllers","text":"<pre><code>@router.post(\"/users\")\nasync def register_user(request: RegisterUserRequest) -&gt; Response:\n    '''HTTP endpoint for user registration.'''\n    result = await register_user_service.execute(request.to_dto())\n    if result.is_ok():\n        return Response(result.value, status_code=201)\n    return Response({\"error\": result.error.reason}, status_code=400)\n</code></pre>"},{"location":"reference/autodoc/application/ports/inbound/message_handler/","title":"Message Handler","text":"<p>Inbound port for handling messages asynchronously.</p>"},{"location":"reference/autodoc/application/ports/inbound/message_handler/#building_blocks.application.ports.inbound.message_handler","title":"<code>message_handler</code>","text":"<p>Inbound port for handling messages asynchronously.</p>"},{"location":"reference/autodoc/application/ports/inbound/message_handler/#building_blocks.application.ports.inbound.message_handler.MessageHandler","title":"<code>MessageHandler</code>","text":"<p>               Bases: <code>InboundPort[MessageType, MessageHandlerResultType]</code>, <code>Protocol</code></p> <p>Inbound port for handling messages asynchronously.</p> <p>This interface defines the contract for handling messages in a CQRS architecture. It is designed to be implemented by message handlers that process incoming messages and perform the necessary actions.</p> <p>Perfect for: - Command handlers - Query handlers (later. this should return a value) - Event handlers - Any other message processing logic</p> Source code in <code>src/building_blocks/application/ports/inbound/message_handler.py</code> <pre><code>class MessageHandler(InboundPort[MessageType, MessageHandlerResultType], Protocol):\n    \"\"\"Inbound port for handling messages asynchronously.\n\n    This interface defines the contract for handling messages in a CQRS\n    architecture. It is designed to be implemented by message handlers that\n    process incoming messages and perform the necessary actions.\n\n    Perfect for:\n    - Command handlers\n    - Query handlers (later. this should return a value)\n    - Event handlers\n    - Any other message processing logic\n    \"\"\"\n\n    async def handle(self, message: MessageType) -&gt; MessageHandlerResultType:\n        \"\"\"Handle a message asynchronously.\n\n        Args:\n            message: The message to be handled.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/inbound/message_handler/#building_blocks.application.ports.inbound.message_handler.MessageHandler.handle","title":"<code>handle(message)</code>  <code>async</code>","text":"<p>Handle a message asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>MessageType</code> <p>The message to be handled.</p> required Source code in <code>src/building_blocks/application/ports/inbound/message_handler.py</code> <pre><code>async def handle(self, message: MessageType) -&gt; MessageHandlerResultType:\n    \"\"\"Handle a message asynchronously.\n\n    Args:\n        message: The message to be handled.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/inbound/use_case/","title":"Use Case","text":"<p>UseCase application inbound port for application use cases.</p>"},{"location":"reference/autodoc/application/ports/inbound/use_case/#building_blocks.application.ports.inbound.use_case","title":"<code>use_case</code>","text":"<p>UseCase application inbound port for application use cases.</p>"},{"location":"reference/autodoc/application/ports/inbound/use_case/#building_blocks.application.ports.inbound.use_case.UseCase","title":"<code>UseCase</code>","text":"<p>               Bases: <code>InboundPort[RequestType, ResponseType]</code>, <code>Protocol</code></p> <p>Marker Protocol application inbound port for use cases.</p> <p>Use cases orchestrate interactions between domain services, repositories, and other components to fulfill application-specific operations.</p> <p>This base class is for asynchronous use cases\u2014implementations should define 'async def execute(self, request: TRequest) -&gt; ResponseType'.</p> Source code in <code>src/building_blocks/application/ports/inbound/use_case.py</code> <pre><code>class UseCase(InboundPort[RequestType, ResponseType], Protocol):\n    \"\"\"Marker Protocol application inbound port for use cases.\n\n    Use cases orchestrate interactions between domain services, repositories,\n    and other components to fulfill application-specific operations.\n\n    This base class is for asynchronous use cases\u2014implementations should define\n    'async def execute(self, request: TRequest) -&gt; ResponseType'.\n    \"\"\"\n\n    async def execute(self, request: RequestType) -&gt; ResponseType:\n        \"\"\"Asynchronous execution of the use case with the provided request.\n\n        This method should be implemented by concrete use case classes to\n        perform the necessary operations and return a response.\n\n        Args:\n            request: The request object containing input data for the use case.\n\n        Returns:\n            The response object containing the result of the use case execution.\n\n        Raises:\n            ValidationError: When request validation fails.\n            ServiceError: When a service operation fails during execution.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/inbound/use_case/#building_blocks.application.ports.inbound.use_case.UseCase.execute","title":"<code>execute(request)</code>  <code>async</code>","text":"<p>Asynchronous execution of the use case with the provided request.</p> <p>This method should be implemented by concrete use case classes to perform the necessary operations and return a response.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>RequestType</code> <p>The request object containing input data for the use case.</p> required <p>Returns:</p> Type Description <code>ResponseType</code> <p>The response object containing the result of the use case execution.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>When request validation fails.</p> <code>ServiceError</code> <p>When a service operation fails during execution.</p> Source code in <code>src/building_blocks/application/ports/inbound/use_case.py</code> <pre><code>async def execute(self, request: RequestType) -&gt; ResponseType:\n    \"\"\"Asynchronous execution of the use case with the provided request.\n\n    This method should be implemented by concrete use case classes to\n    perform the necessary operations and return a response.\n\n    Args:\n        request: The request object containing input data for the use case.\n\n    Returns:\n        The response object containing the result of the use case execution.\n\n    Raises:\n        ValidationError: When request validation fails.\n        ServiceError: When a service operation fails during execution.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/command_sender/","title":"Command Sender","text":"<p>Outbound port for sending commands asynchronously.</p>"},{"location":"reference/autodoc/application/ports/outbound/command_sender/#building_blocks.application.ports.outbound.command_sender","title":"<code>command_sender</code>","text":"<p>Outbound port for sending commands asynchronously.</p>"},{"location":"reference/autodoc/application/ports/outbound/command_sender/#building_blocks.application.ports.outbound.command_sender.CommandSender","title":"<code>CommandSender</code>","text":"<p>Asynchronous outbound port for sending commands.</p> <p>CommandSender is designed to send command messages through a message bus. It is ideal for implementing the command side of a CQRS-like architecture.</p> <p>This implementation is composed with a MessageBus to delegate the actual message dispatching logic.</p> Source code in <code>src/building_blocks/application/ports/outbound/command_sender.py</code> <pre><code>class CommandSender:\n    \"\"\"Asynchronous outbound port for sending commands.\n\n    CommandSender is designed to send command messages through a message bus.\n    It is ideal for implementing the command side of a CQRS-like architecture.\n\n    This implementation is composed with a MessageBus to delegate the actual message dispatching\n    logic.\n    \"\"\"\n\n    def __init__(self, message_bus: MessageBus) -&gt; None:\n        self._message_bus = message_bus\n\n    async def send(self, command: Command) -&gt; None:\n        \"\"\"Send a command asynchronously.\"\"\"\n        await self._message_bus.dispatch(command)\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/command_sender/#building_blocks.application.ports.outbound.command_sender.CommandSender.send","title":"<code>send(command)</code>  <code>async</code>","text":"<p>Send a command asynchronously.</p> Source code in <code>src/building_blocks/application/ports/outbound/command_sender.py</code> <pre><code>async def send(self, command: Command) -&gt; None:\n    \"\"\"Send a command asynchronously.\"\"\"\n    await self._message_bus.dispatch(command)\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/event_publisher/","title":"Event Publisher","text":"<p>Outbound port for publishing domain events asynchronously.</p>"},{"location":"reference/autodoc/application/ports/outbound/event_publisher/#building_blocks.application.ports.outbound.event_publisher","title":"<code>event_publisher</code>","text":"<p>Outbound port for publishing domain events asynchronously.</p>"},{"location":"reference/autodoc/application/ports/outbound/event_publisher/#building_blocks.application.ports.outbound.event_publisher.EventPublisher","title":"<code>EventPublisher</code>","text":"<p>Asynchronous outbound port for publishing events.</p> <p>This interface defines the contract for publishing domain events in a CQRS architecture. It is designed to be implemented by event bus or message broker services, allowing for asynchronous event handling and decoupling of components. Perfect for: - Event-driven architectures - Decoupling domain logic from event handling - Implementing event sourcing patterns - Integrating with message brokers or event buses.</p> Source code in <code>src/building_blocks/application/ports/outbound/event_publisher.py</code> <pre><code>class EventPublisher:\n    \"\"\"Asynchronous outbound port for publishing events.\n\n    This interface defines the contract for publishing domain events in a\n    CQRS architecture. It is designed to be implemented by event bus or\n    message broker services, allowing for asynchronous event handling and\n    decoupling of components.\n    Perfect for:\n    - Event-driven architectures\n    - Decoupling domain logic from event handling\n    - Implementing event sourcing patterns\n    - Integrating with message brokers or event buses.\n    \"\"\"\n\n    def __init__(self, message_bus: MessageBus) -&gt; None:\n        self._message_bus = message_bus\n\n    async def publish(self, event: Event) -&gt; None:\n        \"\"\"Publish an event synchronously.\n\n        Args:\n            event: The domain event to be published.\n        \"\"\"\n        await self._message_bus.dispatch(event)\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/event_publisher/#building_blocks.application.ports.outbound.event_publisher.EventPublisher.publish","title":"<code>publish(event)</code>  <code>async</code>","text":"<p>Publish an event synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The domain event to be published.</p> required Source code in <code>src/building_blocks/application/ports/outbound/event_publisher.py</code> <pre><code>async def publish(self, event: Event) -&gt; None:\n    \"\"\"Publish an event synchronously.\n\n    Args:\n        event: The domain event to be published.\n    \"\"\"\n    await self._message_bus.dispatch(event)\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/message_bus/","title":"Message Bus","text":"<p>Outbound port for a message bus.</p>"},{"location":"reference/autodoc/application/ports/outbound/message_bus/#building_blocks.application.ports.outbound.message_bus","title":"<code>message_bus</code>","text":"<p>Outbound port for a message bus.</p>"},{"location":"reference/autodoc/application/ports/outbound/message_bus/#building_blocks.application.ports.outbound.message_bus.MessageBus","title":"<code>MessageBus</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[MessageBusResponse]</code></p> <p>Asynchronous outbound port for a message bus.</p> Source code in <code>src/building_blocks/application/ports/outbound/message_bus.py</code> <pre><code>class MessageBus(Protocol, Generic[MessageBusResponse]):\n    \"\"\"Asynchronous outbound port for a message bus.\"\"\"\n\n    async def dispatch(self, message: Message) -&gt; MessageBusResponse:\n        \"\"\"Dispatch a message asynchronously.\"\"\"\n        ...\n\n    async def register_handler(self, handler: MessageHandler) -&gt; None:\n        \"\"\"Register a message handler asynchronously.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/message_bus/#building_blocks.application.ports.outbound.message_bus.MessageBus.dispatch","title":"<code>dispatch(message)</code>  <code>async</code>","text":"<p>Dispatch a message asynchronously.</p> Source code in <code>src/building_blocks/application/ports/outbound/message_bus.py</code> <pre><code>async def dispatch(self, message: Message) -&gt; MessageBusResponse:\n    \"\"\"Dispatch a message asynchronously.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/message_bus/#building_blocks.application.ports.outbound.message_bus.MessageBus.register_handler","title":"<code>register_handler(handler)</code>  <code>async</code>","text":"<p>Register a message handler asynchronously.</p> Source code in <code>src/building_blocks/application/ports/outbound/message_bus.py</code> <pre><code>async def register_handler(self, handler: MessageHandler) -&gt; None:\n    \"\"\"Register a message handler asynchronously.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/notifier/","title":"Notifier","text":"<p>Asynchronous notifier interface for sending notifications.</p>"},{"location":"reference/autodoc/application/ports/outbound/notifier/#building_blocks.application.ports.outbound.notifier","title":"<code>notifier</code>","text":"<p>Asynchronous notifier interface for sending notifications.</p>"},{"location":"reference/autodoc/application/ports/outbound/notifier/#building_blocks.application.ports.outbound.notifier.Notifier","title":"<code>Notifier</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[NotificationType]</code></p> <p>Asynchronous notifier interface for sending notifications.</p> <p>This interface defines the contract for sending notifications in an asynchronous manner. It can be implemented by various notification services, such as email, SMS or push notifications.</p> Source code in <code>src/building_blocks/application/ports/outbound/notifier.py</code> <pre><code>class Notifier(Protocol, Generic[NotificationType]):\n    \"\"\"Asynchronous notifier interface for sending notifications.\n\n    This interface defines the contract for sending notifications in an asynchronous\n    manner.\n    It can be implemented by various notification services, such as email, SMS\n    or push notifications.\n    \"\"\"\n\n    async def notify(self, message: NotificationType) -&gt; None:\n        \"\"\"Send a notification with the given message.\n\n        Args:\n            message: The message to be sent in the notification.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/notifier/#building_blocks.application.ports.outbound.notifier.Notifier.notify","title":"<code>notify(message)</code>  <code>async</code>","text":"<p>Send a notification with the given message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>NotificationType</code> <p>The message to be sent in the notification.</p> required Source code in <code>src/building_blocks/application/ports/outbound/notifier.py</code> <pre><code>async def notify(self, message: NotificationType) -&gt; None:\n    \"\"\"Send a notification with the given message.\n\n    Args:\n        message: The message to be sent in the notification.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/query_fetcher/","title":"Query Fetcher","text":"<p>Module for fetching queries via a message bus.</p>"},{"location":"reference/autodoc/application/ports/outbound/query_fetcher/#building_blocks.application.ports.outbound.query_fetcher","title":"<code>query_fetcher</code>","text":"<p>Module for fetching queries via a message bus.</p>"},{"location":"reference/autodoc/application/ports/outbound/query_fetcher/#building_blocks.application.ports.outbound.query_fetcher.QueryFetcher","title":"<code>QueryFetcher</code>","text":"<p>Asynchronous outbound port for fetching queries.</p> <p>QueryFetcher is designed to retrieve data by dispatching query messages through a message bus. It is ideal for implementing the query side if you are applying a CQRS-like architecture.</p> <p>This implementation is composed with a MessageBus to delegate the actual message dispatching logic.</p> Source code in <code>src/building_blocks/application/ports/outbound/query_fetcher.py</code> <pre><code>class QueryFetcher:\n    \"\"\"Asynchronous outbound port for fetching queries.\n\n    QueryFetcher is designed to retrieve data by dispatching query messages through a message bus.\n    It is ideal for implementing the query side if you are applying a CQRS-like architecture.\n\n    This implementation is composed with a MessageBus to delegate the actual message dispatching\n    logic.\n    \"\"\"\n\n    def __init__(self, message_bus: MessageBus) -&gt; None:\n        self._message_bus = message_bus\n\n    async def fetch(self, query: Query) -&gt; Any:\n        \"\"\"Fetch a query asynchronously.\n\n        Args:\n            query: The query to be fetched.\n\n        Returns:\n            The result of the query.\n        \"\"\"\n        return await self._message_bus.dispatch(query)\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/query_fetcher/#building_blocks.application.ports.outbound.query_fetcher.QueryFetcher.fetch","title":"<code>fetch(query)</code>  <code>async</code>","text":"<p>Fetch a query asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>The query to be fetched.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The result of the query.</p> Source code in <code>src/building_blocks/application/ports/outbound/query_fetcher.py</code> <pre><code>async def fetch(self, query: Query) -&gt; Any:\n    \"\"\"Fetch a query asynchronously.\n\n    Args:\n        query: The query to be fetched.\n\n    Returns:\n        The result of the query.\n    \"\"\"\n    return await self._message_bus.dispatch(query)\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/repository/","title":"Repository","text":"<p>Generic repository interfaces for Domain-Driven Design.</p> <p>This module provides a generic repository interface that is parameterized by the aggregate root type and its ID type, providing both flexibility and type safety.</p>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository","title":"<code>repository</code>","text":"<p>Generic repository interfaces for Domain-Driven Design.</p> <p>This module provides a generic repository interface that is parameterized by the aggregate root type and its ID type, providing both flexibility and type safety.</p>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository.ReadOnlyRepository","title":"<code>ReadOnlyRepository</code>","text":"<p>               Bases: <code>Generic[TReadAggregateRoot, TId]</code>, <code>Protocol</code></p> <p>Read-only async repository interface for CQRS query scenarios.</p> <p>This interface is parameterized by both the aggregate root type and its ID type, providing type safety for query-side operations in CQRS architectures.</p> <p>Perfect for: - CQRS query handlers that only need to read data - Read models that are optimized for queries - Enforcing read-only access in query contexts - Separate query databases or read replicas</p> Example <p>from uuid import UUID from building_blocks.domain.aggregate_root import AggregateRoot</p> <p>class Order(AggregateRoot[UUID]): ...     def init(self, id: UUID, customer_id: str, total: float): ...         super().init(id) ...         self._customer_id = customer_id ...         self._total = total ... ...     @property ...     def customer_id(self) -&gt; str: ...         return self._customer_id ... ...     @property ...     def total(self) -&gt; float: ...         return self._total</p> <p>class OrderQueryRepository(AsyncReadOnlyRepository[Order, UUID]): ...     async def get_by_id(self, id: UUID) -&gt; Order | None: ...         # Query implementation - read from optimized read model ...         pass ... ...     async def find_all(self) -&gt; Sequence[Order]: ...         # Query implementation ...         pass ... ...     # Add query-specific methods ...     async def find_by_customer_id( ...         self, customer_id: str ...     ) -&gt; Sequence[Order]: ...         # Optimized for queries ...         pass ... ...     async def get_order_statistics(self) -&gt; dict[str, int]: ...         # Complex query operations ...         pass</p> Source code in <code>src/building_blocks/application/ports/outbound/repository.py</code> <pre><code>class ReadOnlyRepository(Generic[TReadAggregateRoot, TId], Protocol):\n    \"\"\"Read-only async repository interface for CQRS query scenarios.\n\n    This interface is parameterized by both the aggregate root type and its ID type,\n    providing type safety for query-side operations in CQRS architectures.\n\n    Perfect for:\n    - CQRS query handlers that only need to read data\n    - Read models that are optimized for queries\n    - Enforcing read-only access in query contexts\n    - Separate query databases or read replicas\n\n    Example:\n        &gt;&gt;&gt; from uuid import UUID\n        &gt;&gt;&gt; from building_blocks.domain.aggregate_root import AggregateRoot\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class Order(AggregateRoot[UUID]):\n        ...     def __init__(self, id: UUID, customer_id: str, total: float):\n        ...         super().__init__(id)\n        ...         self._customer_id = customer_id\n        ...         self._total = total\n        ...\n        ...     @property\n        ...     def customer_id(self) -&gt; str:\n        ...         return self._customer_id\n        ...\n        ...     @property\n        ...     def total(self) -&gt; float:\n        ...         return self._total\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class OrderQueryRepository(AsyncReadOnlyRepository[Order, UUID]):\n        ...     async def get_by_id(self, id: UUID) -&gt; Order | None:\n        ...         # Query implementation - read from optimized read model\n        ...         pass\n        ...\n        ...     async def find_all(self) -&gt; Sequence[Order]:\n        ...         # Query implementation\n        ...         pass\n        ...\n        ...     # Add query-specific methods\n        ...     async def find_by_customer_id(\n        ...         self, customer_id: str\n        ...     ) -&gt; Sequence[Order]:\n        ...         # Optimized for queries\n        ...         pass\n        ...\n        ...     async def get_order_statistics(self) -&gt; dict[str, int]:\n        ...         # Complex query operations\n        ...         pass\n    \"\"\"\n\n    async def get_by_id(self, id: TId) -&gt; TReadAggregateRoot | None:\n        \"\"\"Find an aggregate by its unique identifier.\n\n        This is optimized for query performance and may read from:\n        - Read replicas\n        - Denormalized read models\n        - Cached projections\n        - Optimized query databases\n\n        Args:\n            id: The unique identifier of the aggregate\n\n        Returns:\n            The aggregate if found, None otherwise\n        \"\"\"\n        ...\n\n    async def list_all(self) -&gt; Sequence[TReadAggregateRoot]:\n        \"\"\"Find all aggregates in the repository.\n\n        Note: In CQRS scenarios, this might be reading from optimized\n        read models rather than the authoritative command store.\n\n        Returns:\n            All aggregates in the repository\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository.ReadOnlyRepository.get_by_id","title":"<code>get_by_id(id)</code>  <code>async</code>","text":"<p>Find an aggregate by its unique identifier.</p> <p>This is optimized for query performance and may read from: - Read replicas - Denormalized read models - Cached projections - Optimized query databases</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TId</code> <p>The unique identifier of the aggregate</p> required <p>Returns:</p> Type Description <code>TReadAggregateRoot | None</code> <p>The aggregate if found, None otherwise</p> Source code in <code>src/building_blocks/application/ports/outbound/repository.py</code> <pre><code>async def get_by_id(self, id: TId) -&gt; TReadAggregateRoot | None:\n    \"\"\"Find an aggregate by its unique identifier.\n\n    This is optimized for query performance and may read from:\n    - Read replicas\n    - Denormalized read models\n    - Cached projections\n    - Optimized query databases\n\n    Args:\n        id: The unique identifier of the aggregate\n\n    Returns:\n        The aggregate if found, None otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository.ReadOnlyRepository.list_all","title":"<code>list_all()</code>  <code>async</code>","text":"<p>Find all aggregates in the repository.</p> <p>Note: In CQRS scenarios, this might be reading from optimized read models rather than the authoritative command store.</p> <p>Returns:</p> Type Description <code>Sequence[TReadAggregateRoot]</code> <p>All aggregates in the repository</p> Source code in <code>src/building_blocks/application/ports/outbound/repository.py</code> <pre><code>async def list_all(self) -&gt; Sequence[TReadAggregateRoot]:\n    \"\"\"Find all aggregates in the repository.\n\n    Note: In CQRS scenarios, this might be reading from optimized\n    read models rather than the authoritative command store.\n\n    Returns:\n        All aggregates in the repository\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository.WriteOnlyRepository","title":"<code>WriteOnlyRepository</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[TWriteAggregateRoot, TWriteId]</code></p> <p>Write-only async repository interface for CQRS command scenarios.</p> <p>This interface is parameterized by the aggregate root type, providing type safety for command-side operations in CQRS architectures.</p> <p>Note: Write-only repositories typically don't need the ID type parameter since they work with aggregate instances that already contain their IDs.</p> <p>Perfect for: - CQRS command handlers that only need to persist changes - Event sourcing scenarios where writes go to event stores - Command-side databases optimized for writes - Enforcing write-only access in command contexts</p> Example <p>from uuid import UUID from building_blocks.domain.aggregate_root import AggregateRoot</p> <p>class Order(AggregateRoot[UUID]): ...     def init(self, id: UUID, customer_id: str): ...         super().init(id) ...         self._customer_id = customer_id ...         self._status = \"pending\" ... ...     def confirm(self) -&gt; None: ...         self._status = \"confirmed\" ...         # Record domain event ...         self.record_event(OrderConfirmedEvent(self.id))</p> <p>class OrderWriteRepository(WriteOnlyRepository[Order, UUID]): ...     def save(self, order: Order) -&gt; None: ...         # Save an Order aggregate ...         pass ... ...     def delete_by_id(self, id: UUID) -&gt; None: ...         # Delete an Order aggregate by ID ...         pass</p> Source code in <code>src/building_blocks/application/ports/outbound/repository.py</code> <pre><code>class WriteOnlyRepository(Protocol, Generic[TWriteAggregateRoot, TWriteId]):\n    \"\"\"Write-only async repository interface for CQRS command scenarios.\n\n    This interface is parameterized by the aggregate root type, providing\n    type safety for command-side operations in CQRS architectures.\n\n    Note: Write-only repositories typically don't need the ID type parameter\n    since they work with aggregate instances that already contain their IDs.\n\n    Perfect for:\n    - CQRS command handlers that only need to persist changes\n    - Event sourcing scenarios where writes go to event stores\n    - Command-side databases optimized for writes\n    - Enforcing write-only access in command contexts\n\n    Example:\n        &gt;&gt;&gt; from uuid import UUID\n        &gt;&gt;&gt; from building_blocks.domain.aggregate_root import AggregateRoot\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class Order(AggregateRoot[UUID]):\n        ...     def __init__(self, id: UUID, customer_id: str):\n        ...         super().__init__(id)\n        ...         self._customer_id = customer_id\n        ...         self._status = \"pending\"\n        ...\n        ...     def confirm(self) -&gt; None:\n        ...         self._status = \"confirmed\"\n        ...         # Record domain event\n        ...         self.record_event(OrderConfirmedEvent(self.id))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class OrderWriteRepository(WriteOnlyRepository[Order, UUID]):\n        ...     def save(self, order: Order) -&gt; None:\n        ...         # Save an Order aggregate\n        ...         pass\n        ...\n        ...     def delete_by_id(self, id: UUID) -&gt; None:\n        ...         # Delete an Order aggregate by ID\n        ...         pass\n    \"\"\"\n\n    async def delete_by_id(self, id: TWriteId) -&gt; None:\n        \"\"\"Delete an aggregate using its id.\n\n        Args:\n            id: The ID of the aggregate to delete.\n\n        Raises:\n            RepositoryException: If deletion fails\n        \"\"\"\n        ...\n\n    async def save(self, aggregate: TWriteAggregateRoot) -&gt; None:\n        \"\"\"Save an aggregate.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository.WriteOnlyRepository.delete_by_id","title":"<code>delete_by_id(id)</code>  <code>async</code>","text":"<p>Delete an aggregate using its id.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TWriteId</code> <p>The ID of the aggregate to delete.</p> required <p>Raises:</p> Type Description <code>RepositoryException</code> <p>If deletion fails</p> Source code in <code>src/building_blocks/application/ports/outbound/repository.py</code> <pre><code>async def delete_by_id(self, id: TWriteId) -&gt; None:\n    \"\"\"Delete an aggregate using its id.\n\n    Args:\n        id: The ID of the aggregate to delete.\n\n    Raises:\n        RepositoryException: If deletion fails\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository.WriteOnlyRepository.save","title":"<code>save(aggregate)</code>  <code>async</code>","text":"<p>Save an aggregate.</p> Source code in <code>src/building_blocks/application/ports/outbound/repository.py</code> <pre><code>async def save(self, aggregate: TWriteAggregateRoot) -&gt; None:\n    \"\"\"Save an aggregate.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/repository/#building_blocks.application.ports.outbound.repository.Repository","title":"<code>Repository</code>","text":"<p>               Bases: <code>ReadOnlyRepository[TAggregateRoot, TId]</code>, <code>WriteOnlyRepository[TAggregateRoot, TId]</code>, <code>Protocol</code></p> <p>Full CRUD async repository interface.</p> <p>This interface combines both read and write operations, providing and end-to-end repository contract.</p> <p>Perfect for: - Standard CRUD operations in non-CQRS scenarios - Simple applications without strict read/write separation - Prototyping and rapid development - When both read and write capabilities are needed.</p> Source code in <code>src/building_blocks/application/ports/outbound/repository.py</code> <pre><code>class Repository(\n    ReadOnlyRepository[TAggregateRoot, TId],\n    WriteOnlyRepository[TAggregateRoot, TId],\n    Protocol,\n):\n    \"\"\"Full CRUD async repository interface.\n\n    This interface combines both read and write operations, providing and end-to-end repository\n    contract.\n\n    Perfect for:\n    - Standard CRUD operations in non-CQRS scenarios\n    - Simple applications without strict read/write separation\n    - Prototyping and rapid development\n    - When both read and write capabilities are needed.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/","title":"Unit Of Work","text":"<p>Unit of Work interface for managing transactions and consistency boundaries.</p>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work","title":"<code>unit_of_work</code>","text":"<p>Unit of Work interface for managing transactions and consistency boundaries.</p>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work.UnitOfWorkError","title":"<code>UnitOfWorkError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Exception raised for errors in the unit of work.</p> Source code in <code>src/building_blocks/application/ports/outbound/unit_of_work.py</code> <pre><code>class UnitOfWorkError(Error):\n    \"\"\"Exception raised for errors in the unit of work.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work.UnitOfWork","title":"<code>UnitOfWork</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for a Unit of Work pattern.</p> <p>The Unit of Work pattern is used to maintain a list of objects affected by a  business transaction and to coordinate the writing out of changes and the resolution of concurrency problems.</p> Source code in <code>src/building_blocks/application/ports/outbound/unit_of_work.py</code> <pre><code>class UnitOfWork(ABC):\n    \"\"\"Abstract base class for a Unit of Work pattern.\n\n    The Unit of Work pattern is used to maintain a list of objects affected by a  business\n    transaction and to coordinate the writing out of changes and the resolution of concurrency\n    problems.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def session(self) -&gt; Any | None:\n        \"\"\"Get the underlying session or transaction context.\n\n        Returns:\n            The session or transaction context, or None if not applicable.\n        \"\"\"\n        ...\n\n    async def __aenter__(self) -&gt; UnitOfWork:\n        \"\"\"Enter the unit of work context.\"\"\"\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit the unit of work context. Commit or rollback based on exceptions.\"\"\"\n        if exc_type is None:\n            await self.commit()\n        else:\n            await self.rollback()\n\n    @abstractmethod\n    async def commit(self) -&gt; None:\n        \"\"\"Commit all changes in the unit of work.\n\n        This should:\n        - Persist all registered changes across repositories\n        - Publish domain events after a successful commit\n        - Handle transaction coordination\n\n        Raises:\n            UnitOfWorkError: If commit fails\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def rollback(self) -&gt; None:\n        \"\"\"Rollback changes in transaction.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work.UnitOfWork.session","title":"<code>session</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the underlying session or transaction context.</p> <p>Returns:</p> Type Description <code>Any | None</code> <p>The session or transaction context, or None if not applicable.</p>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work.UnitOfWork.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the unit of work context.</p> Source code in <code>src/building_blocks/application/ports/outbound/unit_of_work.py</code> <pre><code>async def __aenter__(self) -&gt; UnitOfWork:\n    \"\"\"Enter the unit of work context.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work.UnitOfWork.__aexit__","title":"<code>__aexit__(exc_type, exc_value, traceback)</code>  <code>async</code>","text":"<p>Exit the unit of work context. Commit or rollback based on exceptions.</p> Source code in <code>src/building_blocks/application/ports/outbound/unit_of_work.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit the unit of work context. Commit or rollback based on exceptions.\"\"\"\n    if exc_type is None:\n        await self.commit()\n    else:\n        await self.rollback()\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work.UnitOfWork.commit","title":"<code>commit()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Commit all changes in the unit of work.</p> <p>This should: - Persist all registered changes across repositories - Publish domain events after a successful commit - Handle transaction coordination</p> <p>Raises:</p> Type Description <code>UnitOfWorkError</code> <p>If commit fails</p> Source code in <code>src/building_blocks/application/ports/outbound/unit_of_work.py</code> <pre><code>@abstractmethod\nasync def commit(self) -&gt; None:\n    \"\"\"Commit all changes in the unit of work.\n\n    This should:\n    - Persist all registered changes across repositories\n    - Publish domain events after a successful commit\n    - Handle transaction coordination\n\n    Raises:\n        UnitOfWorkError: If commit fails\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/application/ports/outbound/unit_of_work/#building_blocks.application.ports.outbound.unit_of_work.UnitOfWork.rollback","title":"<code>rollback()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Rollback changes in transaction.</p> Source code in <code>src/building_blocks/application/ports/outbound/unit_of_work.py</code> <pre><code>@abstractmethod\nasync def rollback(self) -&gt; None:\n    \"\"\"Rollback changes in transaction.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/domain/aggregate_root/","title":"Aggregate Root","text":"<p>Module providing the base classes for Aggregate Roots.</p>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root","title":"<code>aggregate_root</code>","text":"<p>Module providing the base classes for Aggregate Roots.</p>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateVersion","title":"<code>AggregateVersion</code>","text":"<p>               Bases: <code>ValueObject[int]</code></p> <p>Value object representing the version of an aggregate root.</p> <p>This is used for optimistic concurrency control to ensure that updates to the aggregate are consistent and do not conflict with other changes.</p> Source code in <code>src/building_blocks/domain/aggregate_root.py</code> <pre><code>class AggregateVersion(ValueObject[int]):\n    \"\"\"Value object representing the version of an aggregate root.\n\n    This is used for optimistic concurrency control to ensure that updates\n    to the aggregate are consistent and do not conflict with other changes.\n    \"\"\"\n\n    def __init__(self, value: int) -&gt; None:\n        if not isinstance(value, int):\n            raise TypeError(f\"Expected int, got {type(value).__name__}\")\n        if value &lt; 0:\n            raise ValueError(\"Version cannot be negative\")\n        self._value = value\n\n    @property\n    def value(self) -&gt; int:\n        \"\"\"Get the raw integer version value.\"\"\"\n        return self._value\n\n    def increment(self) -&gt; AggregateVersion:\n        \"\"\"Return a new AggregateVersion incremented by one.\"\"\"\n        return AggregateVersion(self._value + 1)\n\n    def _equality_components(self) -&gt; tuple[Hashable, ...]:\n        \"\"\"Return the components used for equality comparison.\n\n        This is used by the ValueObject base class to determine equality.\n        \"\"\"\n        return (self._value,)\n</code></pre>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateVersion.value","title":"<code>value</code>  <code>property</code>","text":"<p>Get the raw integer version value.</p>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateVersion.increment","title":"<code>increment()</code>","text":"<p>Return a new AggregateVersion incremented by one.</p> Source code in <code>src/building_blocks/domain/aggregate_root.py</code> <pre><code>def increment(self) -&gt; AggregateVersion:\n    \"\"\"Return a new AggregateVersion incremented by one.\"\"\"\n    return AggregateVersion(self._value + 1)\n</code></pre>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateRoot","title":"<code>AggregateRoot</code>","text":"<p>               Bases: <code>Entity[TId]</code>, <code>Generic[TId]</code>, <code>ABC</code></p> <p>Base class for aggregate roots.</p> <p>An AggregateRoot is a special type of Entity that serves as the entry point for managing a cluster of related entities and value objects. It encapsulates the business logic and invariants of the aggregate, ensuring that all changes to the aggregate are made through its methods. This class is designed to follow the principles of Domain-Driven Design (DDD) and is inspired by Vaughn Vernon's approach in \"Implementing Domain-Driven Design\".</p> <p>This implementation provides methods for managing the aggregate version, recording uncommitted domain events, and marking changes as committed. It is intended to be subclassed to create specific aggregate roots that represent business concepts in the domain.</p> <p>This implementation follows Vaughn Vernon's approach from \"Implementing Domain-Driven Design\" and is designed to be used in and with a Domain-Driven Design context. It provides a foundation for building aggregates that encapsulate business logic and maintain consistency across related entities and value objects.</p> Source code in <code>src/building_blocks/domain/aggregate_root.py</code> <pre><code>class AggregateRoot(Entity[TId], Generic[TId], ABC):\n    \"\"\"Base class for aggregate roots.\n\n    An AggregateRoot is a special type of Entity that serves as the entry point for managing a\n    cluster of related entities and value objects. It encapsulates the business logic and\n    invariants of the aggregate, ensuring that all changes to the aggregate are made through its\n    methods.\n    This class is designed to follow the principles of Domain-Driven Design (DDD) and is inspired\n    by Vaughn Vernon's approach in \"Implementing Domain-Driven Design\".\n\n    This implementation provides methods for managing the aggregate version,\n    recording uncommitted domain events, and marking changes as committed.\n    It is intended to be subclassed to create specific aggregate roots that\n    represent business concepts in the domain.\n\n    This implementation follows Vaughn Vernon's approach from\n    \"Implementing Domain-Driven Design\" and is designed to be used in and\n    with a Domain-Driven Design context.\n    It provides a foundation for building aggregates that encapsulate business\n    logic and maintain consistency across related entities and value objects.\n    \"\"\"\n\n    _uncommitted_events: list[Event]\n\n    def __init__(self, aggregate_id: TId, version: AggregateVersion | None = None) -&gt; None:\n        \"\"\"Initialize the aggregate root.\n\n        Args:\n            aggregate_id: Unique identifier for this aggregate\n            version: Optional initial version for optimistic concurrency control.\n                     If not provided, defaults to AggregateVersion(0).\n        \"\"\"\n        super().__init__(aggregate_id)\n        if not aggregate_id:\n            raise EntityIdNoneError(self.__class__.__name__)\n        self._version = version or AggregateVersion(0)\n        self._uncommitted_events: list[Event] = []\n\n    @property\n    def version(self) -&gt; AggregateVersion:\n        \"\"\"Get the current version of this aggregate.\"\"\"\n        return self._version\n\n    def uncommitted_changes(self) -&gt; list[Event]:\n        \"\"\"Get the uncommitted domain events raised by this aggregate.\n\n        Returns a copy to prevent external modification.\n        Following Vaughn Vernon's naming convention.\n\n        Returns:\n            list[Event]: Copy of uncommitted domain events\n        \"\"\"\n        return self._uncommitted_events.copy()\n\n    def record_event(self, domain_event: Event) -&gt; None:\n        \"\"\"Record a domain event to be published.\n\n        This is the primary method for recording domain events when significant\n        business events occur. Following Vaughn Vernon's naming convention.\n\n        Args:\n            domain_event: The domain event to record\n        \"\"\"\n        self._uncommitted_events.append(domain_event)\n\n    def mark_changes_as_committed(self) -&gt; None:\n        \"\"\"Mark all uncommitted changes as committed and clear them.\n\n        This method should be called after events have been successfully\n        published and the aggregate has been persisted.\n        Following Vaughn Vernon's naming convention.\n        \"\"\"\n        self._uncommitted_events.clear()\n        self._increment_version()\n\n    def _increment_version(self) -&gt; None:\n        \"\"\"Increment the aggregate version.\n\n        Protected method to be called when the aggregate state changes.\n        Useful for optimistic concurrency control.\n        \"\"\"\n        self._version = self._version.increment()\n</code></pre>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateRoot.version","title":"<code>version</code>  <code>property</code>","text":"<p>Get the current version of this aggregate.</p>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateRoot.__init__","title":"<code>__init__(aggregate_id, version=None)</code>","text":"<p>Initialize the aggregate root.</p> <p>Parameters:</p> Name Type Description Default <code>aggregate_id</code> <code>TId</code> <p>Unique identifier for this aggregate</p> required <code>version</code> <code>AggregateVersion | None</code> <p>Optional initial version for optimistic concurrency control.      If not provided, defaults to AggregateVersion(0).</p> <code>None</code> Source code in <code>src/building_blocks/domain/aggregate_root.py</code> <pre><code>def __init__(self, aggregate_id: TId, version: AggregateVersion | None = None) -&gt; None:\n    \"\"\"Initialize the aggregate root.\n\n    Args:\n        aggregate_id: Unique identifier for this aggregate\n        version: Optional initial version for optimistic concurrency control.\n                 If not provided, defaults to AggregateVersion(0).\n    \"\"\"\n    super().__init__(aggregate_id)\n    if not aggregate_id:\n        raise EntityIdNoneError(self.__class__.__name__)\n    self._version = version or AggregateVersion(0)\n    self._uncommitted_events: list[Event] = []\n</code></pre>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateRoot.uncommitted_changes","title":"<code>uncommitted_changes()</code>","text":"<p>Get the uncommitted domain events raised by this aggregate.</p> <p>Returns a copy to prevent external modification. Following Vaughn Vernon's naming convention.</p> <p>Returns:</p> Type Description <code>list[Event]</code> <p>list[Event]: Copy of uncommitted domain events</p> Source code in <code>src/building_blocks/domain/aggregate_root.py</code> <pre><code>def uncommitted_changes(self) -&gt; list[Event]:\n    \"\"\"Get the uncommitted domain events raised by this aggregate.\n\n    Returns a copy to prevent external modification.\n    Following Vaughn Vernon's naming convention.\n\n    Returns:\n        list[Event]: Copy of uncommitted domain events\n    \"\"\"\n    return self._uncommitted_events.copy()\n</code></pre>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateRoot.record_event","title":"<code>record_event(domain_event)</code>","text":"<p>Record a domain event to be published.</p> <p>This is the primary method for recording domain events when significant business events occur. Following Vaughn Vernon's naming convention.</p> <p>Parameters:</p> Name Type Description Default <code>domain_event</code> <code>Event</code> <p>The domain event to record</p> required Source code in <code>src/building_blocks/domain/aggregate_root.py</code> <pre><code>def record_event(self, domain_event: Event) -&gt; None:\n    \"\"\"Record a domain event to be published.\n\n    This is the primary method for recording domain events when significant\n    business events occur. Following Vaughn Vernon's naming convention.\n\n    Args:\n        domain_event: The domain event to record\n    \"\"\"\n    self._uncommitted_events.append(domain_event)\n</code></pre>"},{"location":"reference/autodoc/domain/aggregate_root/#building_blocks.domain.aggregate_root.AggregateRoot.mark_changes_as_committed","title":"<code>mark_changes_as_committed()</code>","text":"<p>Mark all uncommitted changes as committed and clear them.</p> <p>This method should be called after events have been successfully published and the aggregate has been persisted. Following Vaughn Vernon's naming convention.</p> Source code in <code>src/building_blocks/domain/aggregate_root.py</code> <pre><code>def mark_changes_as_committed(self) -&gt; None:\n    \"\"\"Mark all uncommitted changes as committed and clear them.\n\n    This method should be called after events have been successfully\n    published and the aggregate has been persisted.\n    Following Vaughn Vernon's naming convention.\n    \"\"\"\n    self._uncommitted_events.clear()\n    self._increment_version()\n</code></pre>"},{"location":"reference/autodoc/domain/entity/","title":"Entity","text":"<p>Domain entities module.</p> <p>This module provides base classes for domain entities.</p>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity","title":"<code>entity</code>","text":"<p>Domain entities module.</p> <p>This module provides base classes for domain entities.</p>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity","title":"<code>Entity</code>","text":"<p>               Bases: <code>Generic[TId]</code>, <code>ABC</code></p> <p>Base class for domain entities.</p> <p>Entities represent objects with identity. The identity (ID) may be:   - <code>None</code>: Draft entity before persistence (e.g., DB autogenerates ID)   - A valid ID: Assigned before or during construction</p> Behavior <ul> <li>Equality: by ID if both have IDs, otherwise by identity (<code>is</code>)</li> <li>Hashing: allowed only for persisted entities (ID is not None)</li> <li>ID immutability: <code>_id</code> cannot be modified or deleted once set</li> <li>No <code>set_id()</code> method \u2014 lifecycle controlled by Python data model</li> </ul> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>class Entity(Generic[TId], ABC):\n    \"\"\"Base class for domain entities.\n\n    Entities represent objects with identity. The identity (ID) may be:\n      - `None`: Draft entity before persistence (e.g., DB autogenerates ID)\n      - A valid ID: Assigned before or during construction\n\n    Behavior:\n      - Equality: by ID if both have IDs, otherwise by identity (`is`)\n      - Hashing: allowed only for persisted entities (ID is not None)\n      - ID immutability: `_id` cannot be modified or deleted once set\n      - No `set_id()` method \u2014 lifecycle controlled by Python data model\n    \"\"\"\n\n    _id: TId | None\n    __is_frozen: bool\n\n    def __init__(self, entity_id: TId | None) -&gt; None:\n        object.__setattr__(self, \"_id\", entity_id)\n        object.__setattr__(self, \"_Entity__is_frozen\", True)\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        \"\"\"Prevent reassignment of the ID after initialization.\"\"\"\n        if name == \"_id\" and getattr(self, \"_id\", None) is not None:\n            raise AttributeError(f\"Cannot modify 'id' once set ({self._id!r}).\")\n        object.__setattr__(self, name, value)\n\n    def __delattr__(self, name: str) -&gt; None:\n        \"\"\"Prevent deletion of the ID.\"\"\"\n        if name == \"_id\":\n            raise AttributeError(\"Cannot delete 'id'.\")\n        object.__delattr__(self, name)\n\n    @property\n    def id(self) -&gt; TId | None:\n        \"\"\"Unique identifier (may be None for drafts).\"\"\"\n        return self._id\n\n    def is_persisted(self) -&gt; bool:\n        \"\"\"Check if the entity has a defined (non-None) ID.\"\"\"\n        return self._id is not None\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Entity equality comparison magic method.\n\n        Entities are equal if:\n        - They are of the same class AND\n        - Both have IDs and IDs are equal\n        Otherwise, identity equality (same instance).\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        if self._id is None or other._id is None:\n            return self is other\n        return self._id == other._id\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash based on ID; drafts are not hashable.\"\"\"\n        if self._id is None:\n            raise DraftEntityIsNotHashableError.from_class_name(self.__class__.__name__)\n        return hash(self._id)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Readable representation showing ID.\"\"\"\n        return f\"{self.__class__.__name__}(id={self._id})\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Concise representation for debugging.\"\"\"\n        return str(self)\n</code></pre>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.id","title":"<code>id</code>  <code>property</code>","text":"<p>Unique identifier (may be None for drafts).</p>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Prevent reassignment of the ID after initialization.</p> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    \"\"\"Prevent reassignment of the ID after initialization.\"\"\"\n    if name == \"_id\" and getattr(self, \"_id\", None) is not None:\n        raise AttributeError(f\"Cannot modify 'id' once set ({self._id!r}).\")\n    object.__setattr__(self, name, value)\n</code></pre>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.__delattr__","title":"<code>__delattr__(name)</code>","text":"<p>Prevent deletion of the ID.</p> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>def __delattr__(self, name: str) -&gt; None:\n    \"\"\"Prevent deletion of the ID.\"\"\"\n    if name == \"_id\":\n        raise AttributeError(\"Cannot delete 'id'.\")\n    object.__delattr__(self, name)\n</code></pre>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.is_persisted","title":"<code>is_persisted()</code>","text":"<p>Check if the entity has a defined (non-None) ID.</p> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>def is_persisted(self) -&gt; bool:\n    \"\"\"Check if the entity has a defined (non-None) ID.\"\"\"\n    return self._id is not None\n</code></pre>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Entity equality comparison magic method.</p> <p>Entities are equal if: - They are of the same class AND - Both have IDs and IDs are equal Otherwise, identity equality (same instance).</p> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Entity equality comparison magic method.\n\n    Entities are equal if:\n    - They are of the same class AND\n    - Both have IDs and IDs are equal\n    Otherwise, identity equality (same instance).\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        return NotImplemented\n    if self._id is None or other._id is None:\n        return self is other\n    return self._id == other._id\n</code></pre>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash based on ID; drafts are not hashable.</p> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash based on ID; drafts are not hashable.\"\"\"\n    if self._id is None:\n        raise DraftEntityIsNotHashableError.from_class_name(self.__class__.__name__)\n    return hash(self._id)\n</code></pre>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.__str__","title":"<code>__str__()</code>","text":"<p>Readable representation showing ID.</p> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Readable representation showing ID.\"\"\"\n    return f\"{self.__class__.__name__}(id={self._id})\"\n</code></pre>"},{"location":"reference/autodoc/domain/entity/#building_blocks.domain.entity.Entity.__repr__","title":"<code>__repr__()</code>","text":"<p>Concise representation for debugging.</p> Source code in <code>src/building_blocks/domain/entity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Concise representation for debugging.\"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/autodoc/domain/value_object/","title":"Value Object","text":"<p>Domain value objects module.</p> <p>This module provides the base ValueObject class for implementing domain value objects following the principles of Domain-Driven Design (DDD).</p>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object","title":"<code>value_object</code>","text":"<p>Domain value objects module.</p> <p>This module provides the base ValueObject class for implementing domain value objects following the principles of Domain-Driven Design (DDD).</p>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject","title":"<code>ValueObject</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RawValueType]</code></p> <p>Base class for all domain value objects.</p> <p>Value objects are immutable objects defined entirely by their attributes rather than by an identity. Two value objects with the same attributes are considered equal.</p> <p>This base class enforces immutability after initialization by blocking all further attribute assignments once frozen.</p> Example <p>class Email(ValueObject[str]): ...     slots = (\"_value\",) ... ...     def init(self, value: str): ...         super().init() ...         if \"@\" not in value: ...             raise ValueError(\"Invalid email format\") ...         self._value = value ...         self._freeze() ... ...     @property ...     def value(self) -&gt; str: ...         return self._value ... ...     def _equality_components(self) -&gt; tuple[Hashable, ...]: ...         return (self._value,)</p> Source code in <code>src/building_blocks/domain/value_object.py</code> <pre><code>class ValueObject(ABC, Generic[RawValueType]):\n    \"\"\"Base class for all domain value objects.\n\n    Value objects are immutable objects defined entirely by their attributes\n    rather than by an identity. Two value objects with the same attributes\n    are considered equal.\n\n    This base class enforces immutability after initialization by blocking\n    all further attribute assignments once frozen.\n\n    Example:\n        &gt;&gt;&gt; class Email(ValueObject[str]):\n        ...     __slots__ = (\"_value\",)\n        ...\n        ...     def __init__(self, value: str):\n        ...         super().__init__()\n        ...         if \"@\" not in value:\n        ...             raise ValueError(\"Invalid email format\")\n        ...         self._value = value\n        ...         self._freeze()\n        ...\n        ...     @property\n        ...     def value(self) -&gt; str:\n        ...         return self._value\n        ...\n        ...     def _equality_components(self) -&gt; tuple[Hashable, ...]:\n        ...         return (self._value,)\n    \"\"\"\n\n    __is_frozen: bool = False\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the value object in a mutable state (for setup).\"\"\"\n        object.__setattr__(self, \"_ValueObject__is_frozen\", False)\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        \"\"\"Prevent modification once frozen.\"\"\"\n        immutability_error_message = (\n            f\"{self.__class__.__name__} is immutable: cannot modify '{name}' after initialization\"\n        )\n        if getattr(self, \"_ValueObject__is_frozen\", False):\n            raise AttributeError(immutability_error_message)\n        object.__setattr__(self, name, value)\n\n    def _freeze(self) -&gt; None:\n        \"\"\"Freeze the object to enforce immutability.\"\"\"\n        object.__setattr__(self, \"_ValueObject__is_frozen\", True)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality based on equality components.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self._equality_components() == other._equality_components()\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Generate hash based on equality components.\"\"\"\n        return hash(self._equality_components())\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a user-friendly string representation.\"\"\"\n        components = self._equality_components()\n        if len(components) == 1:\n            return f\"{self.__class__.__name__}({components[0]!r})\"\n        return f\"{self.__class__.__name__}{components!r}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a developer-friendly string representation.\"\"\"\n        return self.__str__()\n\n    @property\n    @abstractmethod\n    def value(self) -&gt; RawValueType:\n        \"\"\"Get the primary raw value encapsulated by the ValueObject.\"\"\"\n        pass\n\n    @abstractmethod\n    def _equality_components(self) -&gt; tuple[Hashable, ...]:\n        \"\"\"Return the components used for equality comparison.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject.value","title":"<code>value</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the primary raw value encapsulated by the ValueObject.</p>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the value object in a mutable state (for setup).</p> Source code in <code>src/building_blocks/domain/value_object.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the value object in a mutable state (for setup).\"\"\"\n    object.__setattr__(self, \"_ValueObject__is_frozen\", False)\n</code></pre>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Prevent modification once frozen.</p> Source code in <code>src/building_blocks/domain/value_object.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    \"\"\"Prevent modification once frozen.\"\"\"\n    immutability_error_message = (\n        f\"{self.__class__.__name__} is immutable: cannot modify '{name}' after initialization\"\n    )\n    if getattr(self, \"_ValueObject__is_frozen\", False):\n        raise AttributeError(immutability_error_message)\n    object.__setattr__(self, name, value)\n</code></pre>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality based on equality components.</p> Source code in <code>src/building_blocks/domain/value_object.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality based on equality components.\"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    return self._equality_components() == other._equality_components()\n</code></pre>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject.__hash__","title":"<code>__hash__()</code>","text":"<p>Generate hash based on equality components.</p> Source code in <code>src/building_blocks/domain/value_object.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate hash based on equality components.\"\"\"\n    return hash(self._equality_components())\n</code></pre>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject.__str__","title":"<code>__str__()</code>","text":"<p>Return a user-friendly string representation.</p> Source code in <code>src/building_blocks/domain/value_object.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a user-friendly string representation.\"\"\"\n    components = self._equality_components()\n    if len(components) == 1:\n        return f\"{self.__class__.__name__}({components[0]!r})\"\n    return f\"{self.__class__.__name__}{components!r}\"\n</code></pre>"},{"location":"reference/autodoc/domain/value_object/#building_blocks.domain.value_object.ValueObject.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a developer-friendly string representation.</p> Source code in <code>src/building_blocks/domain/value_object.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a developer-friendly string representation.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"reference/autodoc/domain/errors/draft_entity_is_not_hashable_error/","title":"Draft Entity Is Not Hashable Error","text":"<p>Module defining the DraftEntityIsNotHashableError exception.</p>"},{"location":"reference/autodoc/domain/errors/draft_entity_is_not_hashable_error/#building_blocks.domain.errors.draft_entity_is_not_hashable_error","title":"<code>draft_entity_is_not_hashable_error</code>","text":"<p>Module defining the DraftEntityIsNotHashableError exception.</p>"},{"location":"reference/autodoc/domain/errors/draft_entity_is_not_hashable_error/#building_blocks.domain.errors.draft_entity_is_not_hashable_error.DraftEntityIsNotHashableError","title":"<code>DraftEntityIsNotHashableError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Raised because draft entities are not hashable.</p> Source code in <code>src/building_blocks/domain/errors/draft_entity_is_not_hashable_error.py</code> <pre><code>class DraftEntityIsNotHashableError(Error):\n    \"\"\"Raised because draft entities are not hashable.\"\"\"\n\n    @classmethod\n    def from_class_name(cls, class_name: str) -&gt; DraftEntityIsNotHashableError:\n        \"\"\"Create DraftEntityIsNotHashableError from class name.\"\"\"\n        error_text = f\"{class_name} is not hashable.\"\n        error_text = f\"Unhashable {class_name}: draft entities (id=None) are not hashable\"\n        error_message = ErrorMessage(error_text)\n\n        return cls(error_message)\n</code></pre>"},{"location":"reference/autodoc/domain/errors/draft_entity_is_not_hashable_error/#building_blocks.domain.errors.draft_entity_is_not_hashable_error.DraftEntityIsNotHashableError.from_class_name","title":"<code>from_class_name(class_name)</code>  <code>classmethod</code>","text":"<p>Create DraftEntityIsNotHashableError from class name.</p> Source code in <code>src/building_blocks/domain/errors/draft_entity_is_not_hashable_error.py</code> <pre><code>@classmethod\ndef from_class_name(cls, class_name: str) -&gt; DraftEntityIsNotHashableError:\n    \"\"\"Create DraftEntityIsNotHashableError from class name.\"\"\"\n    error_text = f\"{class_name} is not hashable.\"\n    error_text = f\"Unhashable {class_name}: draft entities (id=None) are not hashable\"\n    error_message = ErrorMessage(error_text)\n\n    return cls(error_message)\n</code></pre>"},{"location":"reference/autodoc/domain/errors/entity_id_none_error/","title":"Entity Id None Error","text":"<p>Module defining the EntityIdNotNoneNotAllowedError.</p>"},{"location":"reference/autodoc/domain/errors/entity_id_none_error/#building_blocks.domain.errors.entity_id_none_error","title":"<code>entity_id_none_error</code>","text":"<p>Module defining the EntityIdNotNoneNotAllowedError.</p>"},{"location":"reference/autodoc/domain/errors/entity_id_none_error/#building_blocks.domain.errors.entity_id_none_error.EntityIdNoneError","title":"<code>EntityIdNoneError</code>","text":"<p>               Bases: <code>NoneNotAllowedError</code></p> <p>Raised when an entity ID is None but should not be.</p> Source code in <code>src/building_blocks/domain/errors/entity_id_none_error.py</code> <pre><code>class EntityIdNoneError(NoneNotAllowedError):\n    \"\"\"Raised when an entity ID is None but should not be.\"\"\"\n\n    def __init__(self, entity_class_name: str) -&gt; None:\n        message = ErrorMessage(f\"Entity ID have to be defined for '{entity_class_name}'.\")\n        metadata = ErrorMetadata(\n            context={\n                \"entity_class_name\": entity_class_name,\n            }\n        )\n        super().__init__(message=message, metadata=metadata)\n</code></pre>"},{"location":"reference/autodoc/domain/messages/command/","title":"Command","text":"<p>Module defining the Command base class for domain commands.</p>"},{"location":"reference/autodoc/domain/messages/command/#building_blocks.domain.messages.command","title":"<code>command</code>","text":"<p>Module defining the Command base class for domain commands.</p>"},{"location":"reference/autodoc/domain/messages/command/#building_blocks.domain.messages.command.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>Message[CommandRawType]</code></p> <p>Base class for all domain commands.</p> <p>Commands represent an intent to do something in the domain. They are requests that may succeed or fail, and they are handled by command handler.</p> <p>Commands are named in imperative mood (e.g., CreateOrder, RegisterCustomer, ProcessPayment).</p> Example <p>class CreateOrder(Command): ...     def init( ...         self, ...         customer_id: str, ...         items: list, ...         metadata: MessageMetadata | None = None ...     ): ...         super().init(metadata) ...         self._customer_id = customer_id ...         self._items = items ... ...     @property ...     def customer_id(self) -&gt; str: ...         return self._customer_id ... ...     @property ...     def items(self) -&gt; list: ...         return self._items ... ...     @property ...     def _payload(self) -&gt; dict[str, Any]: ...         return { ...             \"customer_id\": self._customer_id, ...             \"items\": self._items ...         }</p> Source code in <code>src/building_blocks/domain/messages/command.py</code> <pre><code>class Command(Message[CommandRawType]):\n    \"\"\"Base class for all domain commands.\n\n    Commands represent an intent to do something in the domain.\n    They are requests that may succeed or fail, and they are handled by command handler.\n\n    Commands are named in imperative mood (e.g., CreateOrder, RegisterCustomer,\n    ProcessPayment).\n\n    Example:\n        &gt;&gt;&gt; class CreateOrder(Command):\n        ...     def __init__(\n        ...         self,\n        ...         customer_id: str,\n        ...         items: list,\n        ...         metadata: MessageMetadata | None = None\n        ...     ):\n        ...         super().__init__(metadata)\n        ...         self._customer_id = customer_id\n        ...         self._items = items\n        ...\n        ...     @property\n        ...     def customer_id(self) -&gt; str:\n        ...         return self._customer_id\n        ...\n        ...     @property\n        ...     def items(self) -&gt; list:\n        ...         return self._items\n        ...\n        ...     @property\n        ...     def _payload(self) -&gt; dict[str, Any]:\n        ...         return {\n        ...             \"customer_id\": self._customer_id,\n        ...             \"items\": self._items\n        ...         }\n    \"\"\"\n\n    @property\n    def command_id(self) -&gt; UUID:\n        \"\"\"Get the unique identifier for this command.\n\n        Returns:\n            UUID: The unique command identifier (same as message_id)\n        \"\"\"\n        return self.message_id\n\n    @property\n    def issued_at(self) -&gt; datetime:\n        \"\"\"Get the timestamp when this command was issued.\n\n        Returns:\n            datetime: When the command was issued (same as created_at)\n        \"\"\"\n        return self.created_at\n</code></pre>"},{"location":"reference/autodoc/domain/messages/command/#building_blocks.domain.messages.command.Command.command_id","title":"<code>command_id</code>  <code>property</code>","text":"<p>Get the unique identifier for this command.</p> <p>Returns:</p> Name Type Description <code>UUID</code> <code>UUID</code> <p>The unique command identifier (same as message_id)</p>"},{"location":"reference/autodoc/domain/messages/command/#building_blocks.domain.messages.command.Command.issued_at","title":"<code>issued_at</code>  <code>property</code>","text":"<p>Get the timestamp when this command was issued.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>When the command was issued (same as created_at)</p>"},{"location":"reference/autodoc/domain/messages/event/","title":"Event","text":"<p>Module defining the base Event class for domain events.</p>"},{"location":"reference/autodoc/domain/messages/event/#building_blocks.domain.messages.event","title":"<code>event</code>","text":"<p>Module defining the base Event class for domain events.</p>"},{"location":"reference/autodoc/domain/messages/event/#building_blocks.domain.messages.event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>Message[EventRawType]</code></p> <p>Base class for all domain events.</p> <p>Domain events represent something significant that happened in the domain. They are immutable facts about the past that other parts of the system can react to.</p> <p>Events are named in past tense (e.g., OrderCreated, CustomerRegistered, PaymentProcessed).</p> Example <p>class OrderCreated(Event): ...     def init( ...         self, ...         order_id: str, ...         customer_id: str, ...         total: float, ...         metadata: MessageMetadata | None = None ...     ): ...         super().init(metadata) ...         self._order_id = order_id ...         self._customer_id = customer_id ...         self._total = total ... ...     @property ...     def order_id(self) -&gt; str: ...         return self._order_id ... ...     @property ...     def customer_id(self) -&gt; str: ...         return self._customer_id ... ...     @property ...     def total(self) -&gt; float: ...         return self._total ... ...     @property ...     def payload(self) -&gt; dict[str, Any]: ...         return { ...             \"order_id\": self._order_id, ...             \"customer_id\": self._customer_id, ...             \"total\": self._total ...         }</p> Source code in <code>src/building_blocks/domain/messages/event.py</code> <pre><code>class Event(Message[EventRawType]):\n    \"\"\"Base class for all domain events.\n\n    Domain events represent something significant that happened in the domain.\n    They are immutable facts about the past that other parts of the system can react to.\n\n    Events are named in past tense (e.g., OrderCreated, CustomerRegistered,\n    PaymentProcessed).\n\n    Example:\n        &gt;&gt;&gt; class OrderCreated(Event):\n        ...     def __init__(\n        ...         self,\n        ...         order_id: str,\n        ...         customer_id: str,\n        ...         total: float,\n        ...         metadata: MessageMetadata | None = None\n        ...     ):\n        ...         super().__init__(metadata)\n        ...         self._order_id = order_id\n        ...         self._customer_id = customer_id\n        ...         self._total = total\n        ...\n        ...     @property\n        ...     def order_id(self) -&gt; str:\n        ...         return self._order_id\n        ...\n        ...     @property\n        ...     def customer_id(self) -&gt; str:\n        ...         return self._customer_id\n        ...\n        ...     @property\n        ...     def total(self) -&gt; float:\n        ...         return self._total\n        ...\n        ...     @property\n        ...     def payload(self) -&gt; dict[str, Any]:\n        ...         return {\n        ...             \"order_id\": self._order_id,\n        ...             \"customer_id\": self._customer_id,\n        ...             \"total\": self._total\n        ...         }\n    \"\"\"\n\n    @property\n    def occurred_at(self) -&gt; datetime:\n        \"\"\"Get the timestamp when this event occurred.\n\n        Returns:\n            datetime: When the event occurred (UTC timezone)\n        \"\"\"\n        return self.created_at\n\n    @property\n    @abstractmethod\n    def _payload(self) -&gt; dict[str, Any]:\n        \"\"\"Get the domain-specific data carried by this event.\n\n        Returns:\n            dict[str, object]: The event payload as a dictionary\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/autodoc/domain/messages/event/#building_blocks.domain.messages.event.Event.occurred_at","title":"<code>occurred_at</code>  <code>property</code>","text":"<p>Get the timestamp when this event occurred.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>When the event occurred (UTC timezone)</p>"},{"location":"reference/autodoc/domain/messages/message/","title":"Message","text":"<p>Message module for domain messaging patterns.</p> <p>This module provides the base Message class and MessageMetadata for implementing domain messages following Domain-Driven Design (DDD) and CQRS principles.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message","title":"<code>message</code>","text":"<p>Message module for domain messaging patterns.</p> <p>This module provides the base Message class and MessageMetadata for implementing domain messages following Domain-Driven Design (DDD) and CQRS principles.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata","title":"<code>MessageMetadata</code>","text":"<p>               Bases: <code>ValueObject[dict[str, Any]]</code></p> <p>Metadata associated with domain messages.</p> <p>Contains infrastructure-level information about messages such as: - Unique message identifier - When the message was created - correlation_id is used to trace related messages across systems. - correlation_id is used to link messages that belong to the same business process. - causation_id is used to identify the immediate predecessor message that caused</p> <p>This separation allows messages to focus on domain data while keeping infrastructure concerns in metadata.</p> Example <p>metadata = MessageMetadata(message_type=\"OrderCreated\")</p> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>class MessageMetadata(ValueObject[dict[str, Any]]):\n    \"\"\"Metadata associated with domain messages.\n\n    Contains infrastructure-level information about messages such as:\n    - Unique message identifier\n    - When the message was created\n    - correlation_id is used to trace related messages across systems.\n    - correlation_id is used to link messages that belong to the same business process.\n    - causation_id is used to identify the immediate predecessor message that caused\n\n    This separation allows messages to focus on domain data while keeping\n    infrastructure concerns in metadata.\n\n    Example:\n        &gt;&gt;&gt; metadata = MessageMetadata(message_type=\"OrderCreated\")\n        &gt;&gt;&gt; # Or with custom values\n        &gt;&gt;&gt; custom_metadata = MessageMetadata(\n        ...     message_type=\"UserCreated\",\n        ...     message_id=UUID(\"123e4567-e89b-12d3-a456-426614174000\"),\n        ...     created_at=datetime(2025, 6, 11, 19, 36, 6, tzinfo=timezone.utc)\n        ... )\n    \"\"\"\n\n    def __init__(\n        self,\n        message_type: str,\n        message_id: UUID | None = None,\n        created_at: datetime | None = None,\n        correlation_id: UUID | None = None,\n        causation_id: UUID | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize message metadata.\n\n        Args:\n            message_type: The type/name of the message.\n            message_id: Unique identifier for the message. If None, generates a\n                new UUID.\n            created_at: When the message was created. If None, uses current UTC time.\n            correlation_id: Identifier to correlate related messages. If None,\n                generates a new UUID.\n            causation_id: Identifier of the message that caused this one. If None,\n                generates a new UUID.\n        \"\"\"\n        self._message_type = message_type\n        self._message_id = message_id or uuid4()\n        self._created_at = created_at or now()\n        self._correlation_id = correlation_id or uuid4()\n        self._causation_id = causation_id or uuid4()\n\n    @property\n    def message_id(self) -&gt; UUID:\n        \"\"\"Get the unique identifier for this message.\n\n        Returns:\n            The unique message identifier.\n        \"\"\"\n        return self._message_id\n\n    @property\n    def message_type(self) -&gt; str:\n        \"\"\"Get the type of this message.\n\n        Returns:\n            The message type name.\n        \"\"\"\n        return self._message_type\n\n    @property\n    def causation_id(self) -&gt; UUID:\n        \"\"\"Get the causation ID for this message.\n\n        Returns:\n            The causation identifier.\n        \"\"\"\n        return self._causation_id\n\n    @property\n    def created_at(self) -&gt; datetime:\n        \"\"\"Get the timestamp when this message was created.\n\n        Returns:\n            When the message was created (UTC timezone).\n        \"\"\"\n        return self._created_at\n\n    @property\n    def correlation_id(self) -&gt; UUID:\n        \"\"\"Get the correlation ID for this message.\n\n        Returns:\n            The correlation identifier.\n        \"\"\"\n        return self._correlation_id\n\n    @property\n    def value(self) -&gt; dict[str, Any]:\n        \"\"\"Get the raw dictionary representation of the metadata.\"\"\"\n        return {\n            \"created_at\": self._created_at.isoformat(),\n            \"correlation_id\": str(self._correlation_id),\n            \"causation_id\": str(self._causation_id),\n            \"message_id\": str(self._message_id),\n            \"message_type\": self._message_type,\n        }\n\n    @classmethod\n    def create(cls, message_type: str) -&gt; MessageMetadata:\n        \"\"\"Factory for creating a new metadata instance with a given type.\n\n        Args:\n            message_type: The type/name of the message.\n\n        Returns:\n            A new MessageMetadata instance with generated ID and current timestamp.\n        \"\"\"\n        return cls(message_type=message_type)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert metadata to dictionary representation.\n\n        Returns:\n            Dictionary representation of the metadata.\n        \"\"\"\n        return self.value\n\n    def _equality_components(self) -&gt; tuple[Any, ...]:\n        \"\"\"Message metadata equality is based on message ID and timestamp.\n\n        Returns:\n            Tuple containing message_id and created_at.\n        \"\"\"\n        return (self._message_id, self._created_at)\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata--or-with-custom-values","title":"Or with custom values","text":"<p>custom_metadata = MessageMetadata( ...     message_type=\"UserCreated\", ...     message_id=UUID(\"123e4567-e89b-12d3-a456-426614174000\"), ...     created_at=datetime(2025, 6, 11, 19, 36, 6, tzinfo=timezone.utc) ... )</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.message_id","title":"<code>message_id</code>  <code>property</code>","text":"<p>Get the unique identifier for this message.</p> <p>Returns:</p> Type Description <code>UUID</code> <p>The unique message identifier.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.message_type","title":"<code>message_type</code>  <code>property</code>","text":"<p>Get the type of this message.</p> <p>Returns:</p> Type Description <code>str</code> <p>The message type name.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.causation_id","title":"<code>causation_id</code>  <code>property</code>","text":"<p>Get the causation ID for this message.</p> <p>Returns:</p> Type Description <code>UUID</code> <p>The causation identifier.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.created_at","title":"<code>created_at</code>  <code>property</code>","text":"<p>Get the timestamp when this message was created.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>When the message was created (UTC timezone).</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.correlation_id","title":"<code>correlation_id</code>  <code>property</code>","text":"<p>Get the correlation ID for this message.</p> <p>Returns:</p> Type Description <code>UUID</code> <p>The correlation identifier.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.value","title":"<code>value</code>  <code>property</code>","text":"<p>Get the raw dictionary representation of the metadata.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.__init__","title":"<code>__init__(message_type, message_id=None, created_at=None, correlation_id=None, causation_id=None)</code>","text":"<p>Initialize message metadata.</p> <p>Parameters:</p> Name Type Description Default <code>message_type</code> <code>str</code> <p>The type/name of the message.</p> required <code>message_id</code> <code>UUID | None</code> <p>Unique identifier for the message. If None, generates a new UUID.</p> <code>None</code> <code>created_at</code> <code>datetime | None</code> <p>When the message was created. If None, uses current UTC time.</p> <code>None</code> <code>correlation_id</code> <code>UUID | None</code> <p>Identifier to correlate related messages. If None, generates a new UUID.</p> <code>None</code> <code>causation_id</code> <code>UUID | None</code> <p>Identifier of the message that caused this one. If None, generates a new UUID.</p> <code>None</code> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>def __init__(\n    self,\n    message_type: str,\n    message_id: UUID | None = None,\n    created_at: datetime | None = None,\n    correlation_id: UUID | None = None,\n    causation_id: UUID | None = None,\n) -&gt; None:\n    \"\"\"Initialize message metadata.\n\n    Args:\n        message_type: The type/name of the message.\n        message_id: Unique identifier for the message. If None, generates a\n            new UUID.\n        created_at: When the message was created. If None, uses current UTC time.\n        correlation_id: Identifier to correlate related messages. If None,\n            generates a new UUID.\n        causation_id: Identifier of the message that caused this one. If None,\n            generates a new UUID.\n    \"\"\"\n    self._message_type = message_type\n    self._message_id = message_id or uuid4()\n    self._created_at = created_at or now()\n    self._correlation_id = correlation_id or uuid4()\n    self._causation_id = causation_id or uuid4()\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.create","title":"<code>create(message_type)</code>  <code>classmethod</code>","text":"<p>Factory for creating a new metadata instance with a given type.</p> <p>Parameters:</p> Name Type Description Default <code>message_type</code> <code>str</code> <p>The type/name of the message.</p> required <p>Returns:</p> Type Description <code>MessageMetadata</code> <p>A new MessageMetadata instance with generated ID and current timestamp.</p> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>@classmethod\ndef create(cls, message_type: str) -&gt; MessageMetadata:\n    \"\"\"Factory for creating a new metadata instance with a given type.\n\n    Args:\n        message_type: The type/name of the message.\n\n    Returns:\n        A new MessageMetadata instance with generated ID and current timestamp.\n    \"\"\"\n    return cls(message_type=message_type)\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.MessageMetadata.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert metadata to dictionary representation.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the metadata.</p> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert metadata to dictionary representation.\n\n    Returns:\n        Dictionary representation of the metadata.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.Message","title":"<code>Message</code>","text":"<p>               Bases: <code>ValueObject[MessageRawType]</code>, <code>ABC</code></p> <p>Base class for all domain messages.</p> <p>Messages are immutable value objects that represent intent or facts in the domain. This is the base class for Events (something that happened) and Commands (something to do).</p> <p>Features: - Immutable by design (inherits from ValueObject) - Contains MessageMetadata for infrastructure concerns - Focus on domain data in subclasses - Each message instance is unique (based on metadata.message_id)</p> <p>This class should not be used directly. Use Event or Command instead.</p> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>class Message(ValueObject[MessageRawType], ABC):\n    \"\"\"Base class for all domain messages.\n\n    Messages are immutable value objects that represent intent or facts in the domain.\n    This is the base class for Events (something that happened) and Commands\n    (something to do).\n\n    Features:\n    - Immutable by design (inherits from ValueObject)\n    - Contains MessageMetadata for infrastructure concerns\n    - Focus on domain data in subclasses\n    - Each message instance is unique (based on metadata.message_id)\n\n    This class should not be used directly. Use Event or Command instead.\n    \"\"\"\n\n    def __init__(self, metadata: MessageMetadata | None = None) -&gt; None:\n        \"\"\"Initialize the message with metadata.\n\n        Args:\n            metadata: Message metadata. If None, creates new metadata with\n                generated ID and current timestamp.\n        \"\"\"\n        effective_type = self.__class__.__name__\n        self._metadata = metadata or MessageMetadata(message_type=effective_type)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Check equality based on _equality_components.\"\"\"\n        if not isinstance(other, Message):\n            return False\n        return self._equality_components() == other._equality_components()\n\n    def __hash__(self) -&gt; int:\n        return hash(self._equality_components())\n\n    @property\n    def metadata(self) -&gt; MessageMetadata:\n        \"\"\"Get the message metadata.\n\n        Returns:\n            The message metadata containing ID, timestamp, etc.\n        \"\"\"\n        return self._metadata\n\n    @property\n    def message_id(self) -&gt; UUID:\n        \"\"\"Convenience property to get the message ID.\n\n        Returns:\n            The unique message identifier.\n        \"\"\"\n        return self._metadata.message_id\n\n    @property\n    def created_at(self) -&gt; datetime:\n        \"\"\"Convenience property to get when the message was created.\n\n        Returns:\n            When the message was created.\n        \"\"\"\n        return self._metadata.created_at\n\n    @property\n    @abstractmethod\n    def _payload(self) -&gt; dict[str, Any]:\n        \"\"\"Get the domain-specific data carried by this message.\n\n        Subclasses must implement this property to provide their specific message\n        data. This makes the Message class truly abstract.\n\n        Returns:\n            The message payload.\n        \"\"\"\n        pass\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the message to a dictionary representation.\n\n        Combines metadata, message type, and domain data.\n\n        Returns:\n            Complete dictionary representation of the message.\n        \"\"\"\n        return {\n            \"metadata\": self._metadata.to_dict(),\n            \"payload\": self._payload,\n        }\n\n    def _equality_components(self) -&gt; tuple[Any, ...]:\n        \"\"\"Messages are equal if they have the same message ID.\n\n        Each message instance is unique, even if they have the same domain data.\n\n        Returns:\n            Tuple containing the message ID for equality comparison.\n        \"\"\"\n        return (self._metadata.message_id,)\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.Message.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Get the message metadata.</p> <p>Returns:</p> Type Description <code>MessageMetadata</code> <p>The message metadata containing ID, timestamp, etc.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.Message.message_id","title":"<code>message_id</code>  <code>property</code>","text":"<p>Convenience property to get the message ID.</p> <p>Returns:</p> Type Description <code>UUID</code> <p>The unique message identifier.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.Message.created_at","title":"<code>created_at</code>  <code>property</code>","text":"<p>Convenience property to get when the message was created.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>When the message was created.</p>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.Message.__init__","title":"<code>__init__(metadata=None)</code>","text":"<p>Initialize the message with metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>MessageMetadata | None</code> <p>Message metadata. If None, creates new metadata with generated ID and current timestamp.</p> <code>None</code> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>def __init__(self, metadata: MessageMetadata | None = None) -&gt; None:\n    \"\"\"Initialize the message with metadata.\n\n    Args:\n        metadata: Message metadata. If None, creates new metadata with\n            generated ID and current timestamp.\n    \"\"\"\n    effective_type = self.__class__.__name__\n    self._metadata = metadata or MessageMetadata(message_type=effective_type)\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.Message.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality based on _equality_components.</p> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Check equality based on _equality_components.\"\"\"\n    if not isinstance(other, Message):\n        return False\n    return self._equality_components() == other._equality_components()\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.Message.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the message to a dictionary representation.</p> <p>Combines metadata, message type, and domain data.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Complete dictionary representation of the message.</p> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the message to a dictionary representation.\n\n    Combines metadata, message type, and domain data.\n\n    Returns:\n        Complete dictionary representation of the message.\n    \"\"\"\n    return {\n        \"metadata\": self._metadata.to_dict(),\n        \"payload\": self._payload,\n    }\n</code></pre>"},{"location":"reference/autodoc/domain/messages/message/#building_blocks.domain.messages.message.now","title":"<code>now()</code>","text":"<p>Get the current UTC datetime.</p> Source code in <code>src/building_blocks/domain/messages/message.py</code> <pre><code>def now() -&gt; datetime:\n    \"\"\"Get the current UTC datetime.\"\"\"\n    return datetime.now(timezone.utc)\n</code></pre>"},{"location":"reference/autodoc/domain/messages/query/","title":"Query","text":"<p>Module defining the base Query class for domain queries.</p>"},{"location":"reference/autodoc/domain/messages/query/#building_blocks.domain.messages.query","title":"<code>query</code>","text":"<p>Module defining the base Query class for domain queries.</p>"},{"location":"reference/autodoc/domain/messages/query/#building_blocks.domain.messages.query.Query","title":"<code>Query</code>","text":"<p>               Bases: <code>Message</code>, <code>ABC</code></p> <p>Base class for all domain queries.</p> <p>Queries represent a request to retrieve data from the domain. They are handled by query handlers and should not modify state.</p> <p>Queries are named in interrogative mood (e.g., GetOrder, FindCustomer, listProducts).</p> Example <p>class GetOrder(Query): ...     def init( ...         self, ...         order_id: str, ...         metadata: MessageMetadata | None = None ...     ): ...         super().init(metadata) ...         self._order_id = order_id ... ...     @property ...     def order_id(self) -&gt; str: ...         return self._order_id ... ...     @property ...     def payload(self) -&gt; dict[str, Any]: ...         return { ...             \"order_id\": self._order_id ...         }</p> Source code in <code>src/building_blocks/domain/messages/query.py</code> <pre><code>class Query(Message, ABC):\n    \"\"\"Base class for all domain queries.\n\n    Queries represent a request to retrieve data from the domain.\n    They are handled by query handlers and should not modify state.\n\n    Queries are named in interrogative mood (e.g., GetOrder, FindCustomer,\n    listProducts).\n\n    Example:\n        &gt;&gt;&gt; class GetOrder(Query):\n        ...     def __init__(\n        ...         self,\n        ...         order_id: str,\n        ...         metadata: MessageMetadata | None = None\n        ...     ):\n        ...         super().__init__(metadata)\n        ...         self._order_id = order_id\n        ...\n        ...     @property\n        ...     def order_id(self) -&gt; str:\n        ...         return self._order_id\n        ...\n        ...     @property\n        ...     def payload(self) -&gt; dict[str, Any]:\n        ...         return {\n        ...             \"order_id\": self._order_id\n        ...         }\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def _payload(self) -&gt; dict[str, Any]:\n        \"\"\"Get the domain-specific data carried by this query.\n\n        Returns:\n            dict[str, Any]: The query payload as a dictionary\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/autodoc/foundation/debuggable/","title":"Debuggable","text":"<p>Module defining a protocol for debuggable objects.</p>"},{"location":"reference/autodoc/foundation/debuggable/#building_blocks.foundation.debuggable","title":"<code>debuggable</code>","text":"<p>Module defining a protocol for debuggable objects.</p>"},{"location":"reference/autodoc/foundation/debuggable/#building_blocks.foundation.debuggable.Debuggable","title":"<code>Debuggable</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects that can provide detailed debug string representations.</p> Source code in <code>src/building_blocks/foundation/debuggable.py</code> <pre><code>class Debuggable(Protocol):\n    \"\"\"Protocol for objects that can provide detailed debug string representations.\"\"\"\n\n    def as_debug_string(self) -&gt; str:\n        \"\"\"Return a detailed, multi-line string describing this object for debugging.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/foundation/debuggable/#building_blocks.foundation.debuggable.Debuggable.as_debug_string","title":"<code>as_debug_string()</code>","text":"<p>Return a detailed, multi-line string describing this object for debugging.</p> Source code in <code>src/building_blocks/foundation/debuggable.py</code> <pre><code>def as_debug_string(self) -&gt; str:\n    \"\"\"Return a detailed, multi-line string describing this object for debugging.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/mapper/","title":"Mapper","text":"<p>Mapper Protocol for object transformation.</p>"},{"location":"reference/autodoc/foundation/mapper/#building_blocks.foundation.mapper","title":"<code>mapper</code>","text":"<p>Mapper Protocol for object transformation.</p>"},{"location":"reference/autodoc/foundation/mapper/#building_blocks.foundation.mapper.Mapper","title":"<code>Mapper</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[SourceType, TargetType]</code></p> <p>Maps an object of type SourceType to an object of type TargetType.</p> Example <p>class UserDTO: ...     def init(self, username: str, email: str): ...         self.username = username ...         self.email = email ... class User: ...     def init(self, name: str, contact_email: str): ...         self.name = name ...         self.contact_email = contact_email ... class UserMapper(Mapper[UserDTO, User]): ...     def map(self, source: UserDTO) -&gt; User: ...         return User(name=source.username, contact_email=source.email)</p> Source code in <code>src/building_blocks/foundation/mapper.py</code> <pre><code>class Mapper(Protocol, Generic[SourceType, TargetType]):\n    \"\"\"Maps an object of type SourceType to an object of type TargetType.\n\n    Example:\n        &gt;&gt;&gt; class UserDTO:\n        ...     def __init__(self, username: str, email: str):\n        ...         self.username = username\n        ...         self.email = email\n        ...\n        &gt;&gt;&gt; class User:\n        ...     def __init__(self, name: str, contact_email: str):\n        ...         self.name = name\n        ...         self.contact_email = contact_email\n        ...\n        &gt;&gt;&gt; class UserMapper(Mapper[UserDTO, User]):\n        ...     def map(self, source: UserDTO) -&gt; User:\n        ...         return User(name=source.username, contact_email=source.email)\n    \"\"\"\n\n    def map(self, source: SourceType) -&gt; TargetType:\n        \"\"\"Map an object of type SourceType to an object of type TargetType.\n\n        Args:\n            source (SourceType): The source object to map.\n\n        Returns:\n            TargetType: The mapped target object.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/foundation/mapper/#building_blocks.foundation.mapper.Mapper.map","title":"<code>map(source)</code>","text":"<p>Map an object of type SourceType to an object of type TargetType.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>SourceType</code> <p>The source object to map.</p> required <p>Returns:</p> Name Type Description <code>TargetType</code> <code>TargetType</code> <p>The mapped target object.</p> Source code in <code>src/building_blocks/foundation/mapper.py</code> <pre><code>def map(self, source: SourceType) -&gt; TargetType:\n    \"\"\"Map an object of type SourceType to an object of type TargetType.\n\n    Args:\n        source (SourceType): The source object to map.\n\n    Returns:\n        TargetType: The mapped target object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/","title":"Ports","text":"<p>Foundational Protocol Interfaces.</p> <p>Defines general-purpose protocol interfaces for type-annotated contracts. These are \"super interfaces\" (marker protocols) that you extend to create your own interface definitions with excellent IDE support and architectural flexibility. They impose no framework or layout requirements.</p>"},{"location":"reference/autodoc/foundation/ports/#what-are-these-protocols","title":"WHAT ARE THESE PROTOCOLS?","text":"<p>.. code-block:: text</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  WHAT ARE THESE PROTOCOLS?                                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                             \u2502\n\u2502  Port, InboundPort, and OutboundPort are generic Protocol classes that      \u2502\n\u2502  serve as foundations for your own interface definitions.                   \u2502\n\u2502                                                                             \u2502\n\u2502  \u2713 They Provide:                                                            \u2502\n\u2502    \u2022 Generic type parameters (InputType, OutputType)                        \u2502\n\u2502    \u2022 Structural typing support (PEP 544)                                    \u2502\n\u2502    \u2022 Consistent naming conventions                                          \u2502\n\u2502    \u2022 IDE autocomplete and static analysis                                   \u2502\n\u2502    \u2022 Zero dependencies or framework requirements                            \u2502\n\u2502                                                                             \u2502\n\u2502  \u2717 They DON'T Provide:                                                      \u2502\n\u2502    \u2022 Any predefined methods                                                 \u2502\n\u2502    \u2022 Architectural constraints or patterns                                  \u2502\n\u2502    \u2022 Implementation requirements                                            \u2502\n\u2502    \u2022 Framework or library dependencies                                      \u2502\n\u2502                                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#quick-start-the-three-step-pattern","title":"QUICK START: THE THREE-STEP PATTERN","text":"<p>Step 1: Define Your Protocol (extend + add methods) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>.. code-block:: python</p> <pre><code>from building_blocks.foundation.ports import OutboundPort\n\nclass UserRepository(OutboundPort[UserID, User]):\n    # Repository interface for user persistence.\n\n    def find_by_id(self, id: UserID) -&gt; User | None:\n        # Retrieve a user by their unique ID.\n        ...\n\n    def find_by_email(self, email: str) -&gt; User | None:\n        # Retrieve a user by their email address.\n        ...\n\n    def save(self, user: User) -&gt; None:\n        # Persist a user (insert or update).\n        ...\n\n    def delete(self, id: UserID) -&gt; bool:\n        # Remove a user. Returns True if user existed.\n        ...\n</code></pre> <p>Step 2: Implement It (as many times as needed)</p> <pre><code>\n.. code-block:: python\n\n    # Production: PostgreSQL implementation\n    class PostgresUserRepository:\n        def __init__(self, connection_pool):\n            self.db = connection_pool\n\n        def find_by_id(self, id: UserID) -&gt; User | None:\n            row = self.db.query_one(\"SELECT * FROM users WHERE id = $1\", id)\n            return User.from_row(row) if row else None\n\n        def find_by_email(self, email: str) -&gt; User | None:\n            row = self.db.query_one(\"SELECT * FROM users WHERE email = $1\", email)\n            return User.from_row(row) if row else None\n\n        def save(self, user: User) -&gt; None:\n            self.db.execute(\n                (\n                    \"INSERT INTO users (id, email, name) \"\n                    \"VALUES ($1, $2, $3) \"\n                    \"ON CONFLICT (id) DO UPDATE SET email=$2, name=$3\"\n                ),\n                user.id, user.email, user.name\n            )\n\n        def delete(self, id: UserID) -&gt; bool:\n            result = self.db.execute(\"DELETE FROM users WHERE id = $1\", id)\n            return result.rowcount &gt; 0\n\n    # Testing: In-memory fake implementation\n    class InMemoryUserRepository:\n        def __init__(self):\n            self._users: dict[UserID, User] = {}\n            self._by_email: dict[str, UserID] = {}\n\n        def find_by_id(self, id: UserID) -&gt; User | None:\n            return self._users.get(id)\n\n        def find_by_email(self, email: str) -&gt; User | None:\n            user_id = self._by_email.get(email)\n            return self._users.get(user_id) if user_id else None\n\n        def save(self, user: User) -&gt; None:\n            self._users[user.id] = user\n            self._by_email[user.email] = user.id\n\n        def delete(self, id: UserID) -&gt; bool:\n            if id in self._users:\n                user = self._users.pop(id)\n                self._by_email.pop(user.email, None)\n                return True\n            return False\n\nStep 3: Use Type Hints (swap implementations freely)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    def register_new_user(\n        repository: UserRepository,  # \u2190 The protocol, not the implementation\n        email: str,\n        name: str\n    ) -&gt; User:\n        # Register a new user account.\n        existing = repository.find_by_email(email)\n        if existing:\n            raise ValueError(f\"Email {email} is already registered\")\n\n        user = User(id=generate_id(), email=email, name=name)\n        repository.save(user)\n        return user\n\n    # Production: use real database\n    db_repo = PostgresUserRepository(db_pool)\n    user = register_new_user(db_repo, \"alice@example.com\", \"Alice\")\n\n    # Testing: use in-memory fake (fast, no database needed!)\n    test_repo = InMemoryUserRepository()\n    user = register_new_user(test_repo, \"bob@example.com\", \"Bob\")\n\nPROTOCOL HIERARCHY\n------------------\n\n.. code-block:: text\n\n    Port[InputType, OutputType]\n     \u2502\n     \u251c\u2500\u2500 InboundPort[InputType, OutputType]  (alias: InputPort)\n     \u2502    \u2514\u2500\u2192 For operations that receive and process input\n     \u2502        Examples: handlers, processors, validators, executors\n     \u2502\n     \u2514\u2500\u2500 OutboundPort[InputType, OutputType] (alias: OutputPort)\n          \u2514\u2500\u2192 For operations that interact with external systems\n              Examples: repositories, caches, APIs, message brokers\n\n    All three are marker protocols \u2014 they define no methods.\n    You extend them and add your own method signatures.\n\nWHY USE THESE PROTOCOLS?\n------------------------\n\nType Annotations (static analysis at dev time)\n</code></pre> <p>.. code-block:: python</p> <pre><code>def process(repo: UserRepository, id: UserID):\n    user = repo.find_by_id(id)    # static analyzers infer the return type\n    # user.invalid_method()       # analyzers flag this as an error\n</code></pre> <p>IDE Support</p> <pre><code>\nModern IDEs provide autocomplete, jump-to-definition, and inline documentation\nfor protocol-based interfaces.\n\n.. code-block:: python\n\n    repo.find_  # \u2190 IDE shows: find_by_id(), find_by_email()\n\nTestability\n</code></pre> <p>Swap real implementations with test doubles (fakes, mocks, stubs) without changing your business logic.</p> <p>.. code-block:: python</p> <pre><code># Production\nservice = UserService(PostgresUserRepository(db))\n\n# Testing\nservice = UserService(InMemoryUserRepository())\n</code></pre> <p>Flexibility ~~~~~~~~~~~</p> <p>Multiple implementations of the same interface; change implementations without modifying callers.</p> <p>Documentation ~~~~~~~~~~~~~</p> <p>Protocols make contracts explicit and self-documenting through type hints. The interface defines what's expected, not how it's implemented.</p> <p>Independence ~~~~~~~~~~~~</p> <p>No framework dependencies. No architectural constraints. Works in any Python application structure.</p>"},{"location":"reference/autodoc/foundation/ports/#type-parameters-explained","title":"TYPE PARAMETERS EXPLAINED","text":"<p>InputType: The data type your operations work with ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>Often represents:</p> <ul> <li>IDs for lookup operations (UserID, ProductID, OrderID)</li> <li>Query objects for search operations (SearchQuery, Filter)</li> <li>Data to be processed or validated (FormData, Document)</li> <li>Keys for cache operations (CacheKey, str)</li> <li>Commands or requests (CreateUserCommand, PaymentRequest)</li> </ul> <p>Examples: - Repository[UserID, User]           # Input: ID - Cache[str, bytes]                  # Input: cache key - Processor[RawData, ProcessedData]  # Input: data to process</p> <p>OutputType: The data type your operations return ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>Often represents:</p> <ul> <li>Entities or aggregates (User, Product, Order)</li> <li>Result objects (SearchResult, ValidationResult, PaymentResult)</li> <li>Optional data (User | None)</li> <li>Collections (list[Product], dict[str, Any])</li> <li>Status or confirmation (bool, None)</li> </ul> <p>Examples: - Repository[UserID, User]           # Output: User entity - Cache[str, bytes]                  # Output: cached bytes - Validator[Data, list[Error]]       # Output: list of errors</p>"},{"location":"reference/autodoc/foundation/ports/#structural-typing-pep-544","title":"STRUCTURAL TYPING (PEP 544)","text":"<p>Implementations don't need to explicitly inherit from your protocols. They only need to implement the required methods (structural subtyping).</p> <p>.. code-block:: python</p> <pre><code>class MyRepository:  # No inheritance needed\n    def find_by_id(self, id: UserID) -&gt; User | None:\n        return self._users.get(id)\n\n    def save(self, user: User) -&gt; None:\n        self._users[user.id] = user\n\nrepo: UserRepository = MyRepository()  # static analyzers accept this\n</code></pre> <p>You can also inherit explicitly (optional):</p> <p>.. code-block:: python</p> <pre><code>class MyRepository(UserRepository):  # Explicit inheritance\n    def find_by_id(self, id: UserID) -&gt; User | None:\n        return self._users.get(id)\n\n    def save(self, user: User) -&gt; None:\n        self._users[user.id] = user\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#common-usage-patterns","title":"COMMON USAGE PATTERNS","text":"<p>Pattern 1: Repository (Data Persistence) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>.. code-block:: python</p> <pre><code>class ProductRepository(OutboundPort[ProductID, Product]):\n    def find_by_id(self, id: ProductID) -&gt; Product | None: ...\n    def find_by_category(self, category: str) -&gt; list[Product]: ...\n    def save(self, product: Product) -&gt; None: ...\n    def delete(self, id: ProductID) -&gt; bool: ...\n</code></pre> <p>Pattern 2: Cache (Fast Data Access)</p> <pre><code>\n.. code-block:: python\n\n    class SessionCache(OutboundPort[SessionID, SessionData]):\n        async def get(self, id: SessionID) -&gt; SessionData | None: ...\n        async def set(self, id: SessionID, data: SessionData, ttl: int) -&gt; None: ...\n        async def delete(self, id: SessionID) -&gt; bool: ...\n\nPattern 3: Use Case / Command Handler (Business Logic)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class CreateOrderUseCase(InboundPort[OrderData, Order]):\n        def execute(self, data: OrderData) -&gt; Order: ...\n        def validate(self, data: OrderData) -&gt; list[ValidationError]: ...\n\nPattern 4: Query Handler (Data Retrieval)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class SearchProducts(InboundPort[SearchQuery, SearchResult]):\n        async def search(self, query: SearchQuery) -&gt; SearchResult: ...\n        async def suggest(self, partial: str) -&gt; list[str]: ...\n\nPattern 5: External API Client (Third-Party Integration)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class PaymentGateway(OutboundPort[PaymentRequest, PaymentResult]):\n        async def charge(self, request: PaymentRequest) -&gt; PaymentResult: ...\n        async def refund(self, transaction_id: str) -&gt; PaymentResult: ...\n\nPattern 6: Message Broker (Async Communication)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class EventPublisher(OutboundPort[DomainEvent, None]):\n        async def publish(self, event: DomainEvent) -&gt; None: ...\n        async def publish_batch(self, events: list[DomainEvent]) -&gt; None: ...\n\nPattern 7: Notification Gateway (Multi-Channel Messaging)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class NotificationSender(OutboundPort[Notification, bool]):\n        async def send_email(self, notification: Notification) -&gt; bool: ...\n        async def send_sms(self, notification: Notification) -&gt; bool: ...\n        async def send_push(self, notification: Notification) -&gt; bool: ...\n\nUSAGE IN DIFFERENT ARCHITECTURES\n--------------------------------\n\nThese protocols are architecture-agnostic and work in any structure:\n\n- Layered Architecture \u2014 use ports to define boundaries between layers\n- MVC Applications \u2014 define contracts between models, views, controllers\n- Microservices \u2014 define ports for service-to-service communication\n- Single-File Scripts \u2014 use ports even in simple scripts for testability\n- Domain-Driven Design \u2014 repositories and domain services as ports\n- Hexagonal / Ports-and-Adapters \u2014 a natural fit\n- Clean Architecture \u2014 ports define boundaries and dependencies\n- Your Custom Structure \u2014 no assumptions\n\nTESTING STRATEGIES\n------------------\n\nStrategy 1: In-Memory Fakes (Fast Unit Tests)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    # Production\n    repo = PostgresUserRepository(db_pool)\n\n    # Testing (no database, instant)\n    repo = InMemoryUserRepository()\n\n    # Test runs in microseconds\n    user = User(id=\"123\", email=\"test@example.com\")\n    repo.save(user)\n    assert repo.find_by_id(\"123\") == user\n\nStrategy 2: Mock Objects (Verify Interactions)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    from unittest.mock import Mock\n\n    mock_repo = Mock(spec=UserRepository)\n    mock_repo.find_by_id.return_value = User(...)\n\n    service = UserService(mock_repo)\n    service.get_user(\"123\")\n\n    mock_repo.find_by_id.assert_called_once_with(\"123\")\n\nStrategy 3: Test Doubles with State\n</code></pre> <p>.. code-block:: python</p> <pre><code>class SpyRepository:\n    def __init__(self):\n        self.saved_users = []\n        self.deleted_ids = []\n\n    def save(self, user: User) -&gt; None:\n        self.saved_users.append(user)\n\n    def delete(self, id: UserID) -&gt; bool:\n        self.deleted_ids.append(id)\n        return True\n\n# Verify behavior\nspy = SpyRepository()\nservice.register_user(spy, \"alice@example.com\", \"Alice\")\nassert len(spy.saved_users) == 1\nassert spy.saved_users[0].email == \"alice@example.com\"\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#protocol-definitions","title":"PROTOCOL DEFINITIONS","text":"<p>See Also: - PEP 544 \u2014 Protocols: Structural subtyping (static duck typing) - typing.Protocol \u2014 Python's Protocol implementation</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports","title":"<code>ports</code>","text":"<p>Foundational Protocol Interfaces.</p> <p>Defines general-purpose protocol interfaces for type-annotated contracts. These are \"super interfaces\" (marker protocols) that you extend to create your own interface definitions with excellent IDE support and architectural flexibility. They impose no framework or layout requirements.</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports--what-are-these-protocols","title":"WHAT ARE THESE PROTOCOLS?","text":"<p>.. code-block:: text</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  WHAT ARE THESE PROTOCOLS?                                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                             \u2502\n\u2502  Port, InboundPort, and OutboundPort are generic Protocol classes that      \u2502\n\u2502  serve as foundations for your own interface definitions.                   \u2502\n\u2502                                                                             \u2502\n\u2502  \u2713 They Provide:                                                            \u2502\n\u2502    \u2022 Generic type parameters (InputType, OutputType)                        \u2502\n\u2502    \u2022 Structural typing support (PEP 544)                                    \u2502\n\u2502    \u2022 Consistent naming conventions                                          \u2502\n\u2502    \u2022 IDE autocomplete and static analysis                                   \u2502\n\u2502    \u2022 Zero dependencies or framework requirements                            \u2502\n\u2502                                                                             \u2502\n\u2502  \u2717 They DON'T Provide:                                                      \u2502\n\u2502    \u2022 Any predefined methods                                                 \u2502\n\u2502    \u2022 Architectural constraints or patterns                                  \u2502\n\u2502    \u2022 Implementation requirements                                            \u2502\n\u2502    \u2022 Framework or library dependencies                                      \u2502\n\u2502                                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports--quick-start-the-three-step-pattern","title":"QUICK START: THE THREE-STEP PATTERN","text":"<p>Step 1: Define Your Protocol (extend + add methods) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>.. code-block:: python</p> <pre><code>from building_blocks.foundation.ports import OutboundPort\n\nclass UserRepository(OutboundPort[UserID, User]):\n    # Repository interface for user persistence.\n\n    def find_by_id(self, id: UserID) -&gt; User | None:\n        # Retrieve a user by their unique ID.\n        ...\n\n    def find_by_email(self, email: str) -&gt; User | None:\n        # Retrieve a user by their email address.\n        ...\n\n    def save(self, user: User) -&gt; None:\n        # Persist a user (insert or update).\n        ...\n\n    def delete(self, id: UserID) -&gt; bool:\n        # Remove a user. Returns True if user existed.\n        ...\n</code></pre> <p>Step 2: Implement It (as many times as needed)</p> <pre><code>\n.. code-block:: python\n\n    # Production: PostgreSQL implementation\n    class PostgresUserRepository:\n        def __init__(self, connection_pool):\n            self.db = connection_pool\n\n        def find_by_id(self, id: UserID) -&gt; User | None:\n            row = self.db.query_one(\"SELECT * FROM users WHERE id = $1\", id)\n            return User.from_row(row) if row else None\n\n        def find_by_email(self, email: str) -&gt; User | None:\n            row = self.db.query_one(\"SELECT * FROM users WHERE email = $1\", email)\n            return User.from_row(row) if row else None\n\n        def save(self, user: User) -&gt; None:\n            self.db.execute(\n                (\n                    \"INSERT INTO users (id, email, name) \"\n                    \"VALUES ($1, $2, $3) \"\n                    \"ON CONFLICT (id) DO UPDATE SET email=$2, name=$3\"\n                ),\n                user.id, user.email, user.name\n            )\n\n        def delete(self, id: UserID) -&gt; bool:\n            result = self.db.execute(\"DELETE FROM users WHERE id = $1\", id)\n            return result.rowcount &gt; 0\n\n    # Testing: In-memory fake implementation\n    class InMemoryUserRepository:\n        def __init__(self):\n            self._users: dict[UserID, User] = {}\n            self._by_email: dict[str, UserID] = {}\n\n        def find_by_id(self, id: UserID) -&gt; User | None:\n            return self._users.get(id)\n\n        def find_by_email(self, email: str) -&gt; User | None:\n            user_id = self._by_email.get(email)\n            return self._users.get(user_id) if user_id else None\n\n        def save(self, user: User) -&gt; None:\n            self._users[user.id] = user\n            self._by_email[user.email] = user.id\n\n        def delete(self, id: UserID) -&gt; bool:\n            if id in self._users:\n                user = self._users.pop(id)\n                self._by_email.pop(user.email, None)\n                return True\n            return False\n\nStep 3: Use Type Hints (swap implementations freely)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    def register_new_user(\n        repository: UserRepository,  # \u2190 The protocol, not the implementation\n        email: str,\n        name: str\n    ) -&gt; User:\n        # Register a new user account.\n        existing = repository.find_by_email(email)\n        if existing:\n            raise ValueError(f\"Email {email} is already registered\")\n\n        user = User(id=generate_id(), email=email, name=name)\n        repository.save(user)\n        return user\n\n    # Production: use real database\n    db_repo = PostgresUserRepository(db_pool)\n    user = register_new_user(db_repo, \"alice@example.com\", \"Alice\")\n\n    # Testing: use in-memory fake (fast, no database needed!)\n    test_repo = InMemoryUserRepository()\n    user = register_new_user(test_repo, \"bob@example.com\", \"Bob\")\n\nPROTOCOL HIERARCHY\n------------------\n\n.. code-block:: text\n\n    Port[InputType, OutputType]\n     \u2502\n     \u251c\u2500\u2500 InboundPort[InputType, OutputType]  (alias: InputPort)\n     \u2502    \u2514\u2500\u2192 For operations that receive and process input\n     \u2502        Examples: handlers, processors, validators, executors\n     \u2502\n     \u2514\u2500\u2500 OutboundPort[InputType, OutputType] (alias: OutputPort)\n          \u2514\u2500\u2192 For operations that interact with external systems\n              Examples: repositories, caches, APIs, message brokers\n\n    All three are marker protocols \u2014 they define no methods.\n    You extend them and add your own method signatures.\n\nWHY USE THESE PROTOCOLS?\n------------------------\n\nType Annotations (static analysis at dev time)\n</code></pre> <p>.. code-block:: python</p> <pre><code>def process(repo: UserRepository, id: UserID):\n    user = repo.find_by_id(id)    # static analyzers infer the return type\n    # user.invalid_method()       # analyzers flag this as an error\n</code></pre> <p>IDE Support</p> <pre><code>\nModern IDEs provide autocomplete, jump-to-definition, and inline documentation\nfor protocol-based interfaces.\n\n.. code-block:: python\n\n    repo.find_  # \u2190 IDE shows: find_by_id(), find_by_email()\n\nTestability\n</code></pre> <p>Swap real implementations with test doubles (fakes, mocks, stubs) without changing your business logic.</p> <p>.. code-block:: python</p> <pre><code># Production\nservice = UserService(PostgresUserRepository(db))\n\n# Testing\nservice = UserService(InMemoryUserRepository())\n</code></pre> <p>Flexibility ~~~~~~~~~~~</p> <p>Multiple implementations of the same interface; change implementations without modifying callers.</p> <p>Documentation ~~~~~~~~~~~~~</p> <p>Protocols make contracts explicit and self-documenting through type hints. The interface defines what's expected, not how it's implemented.</p> <p>Independence ~~~~~~~~~~~~</p> <p>No framework dependencies. No architectural constraints. Works in any Python application structure.</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports--type-parameters-explained","title":"TYPE PARAMETERS EXPLAINED","text":"<p>InputType: The data type your operations work with ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>Often represents:</p> <ul> <li>IDs for lookup operations (UserID, ProductID, OrderID)</li> <li>Query objects for search operations (SearchQuery, Filter)</li> <li>Data to be processed or validated (FormData, Document)</li> <li>Keys for cache operations (CacheKey, str)</li> <li>Commands or requests (CreateUserCommand, PaymentRequest)</li> </ul> <p>Examples: - Repository[UserID, User]           # Input: ID - Cache[str, bytes]                  # Input: cache key - Processor[RawData, ProcessedData]  # Input: data to process</p> <p>OutputType: The data type your operations return ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>Often represents:</p> <ul> <li>Entities or aggregates (User, Product, Order)</li> <li>Result objects (SearchResult, ValidationResult, PaymentResult)</li> <li>Optional data (User | None)</li> <li>Collections (list[Product], dict[str, Any])</li> <li>Status or confirmation (bool, None)</li> </ul> <p>Examples: - Repository[UserID, User]           # Output: User entity - Cache[str, bytes]                  # Output: cached bytes - Validator[Data, list[Error]]       # Output: list of errors</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports--structural-typing-pep-544","title":"STRUCTURAL TYPING (PEP 544)","text":"<p>Implementations don't need to explicitly inherit from your protocols. They only need to implement the required methods (structural subtyping).</p> <p>.. code-block:: python</p> <pre><code>class MyRepository:  # No inheritance needed\n    def find_by_id(self, id: UserID) -&gt; User | None:\n        return self._users.get(id)\n\n    def save(self, user: User) -&gt; None:\n        self._users[user.id] = user\n\nrepo: UserRepository = MyRepository()  # static analyzers accept this\n</code></pre> <p>You can also inherit explicitly (optional):</p> <p>.. code-block:: python</p> <pre><code>class MyRepository(UserRepository):  # Explicit inheritance\n    def find_by_id(self, id: UserID) -&gt; User | None:\n        return self._users.get(id)\n\n    def save(self, user: User) -&gt; None:\n        self._users[user.id] = user\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports--common-usage-patterns","title":"COMMON USAGE PATTERNS","text":"<p>Pattern 1: Repository (Data Persistence) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> <p>.. code-block:: python</p> <pre><code>class ProductRepository(OutboundPort[ProductID, Product]):\n    def find_by_id(self, id: ProductID) -&gt; Product | None: ...\n    def find_by_category(self, category: str) -&gt; list[Product]: ...\n    def save(self, product: Product) -&gt; None: ...\n    def delete(self, id: ProductID) -&gt; bool: ...\n</code></pre> <p>Pattern 2: Cache (Fast Data Access)</p> <pre><code>\n.. code-block:: python\n\n    class SessionCache(OutboundPort[SessionID, SessionData]):\n        async def get(self, id: SessionID) -&gt; SessionData | None: ...\n        async def set(self, id: SessionID, data: SessionData, ttl: int) -&gt; None: ...\n        async def delete(self, id: SessionID) -&gt; bool: ...\n\nPattern 3: Use Case / Command Handler (Business Logic)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class CreateOrderUseCase(InboundPort[OrderData, Order]):\n        def execute(self, data: OrderData) -&gt; Order: ...\n        def validate(self, data: OrderData) -&gt; list[ValidationError]: ...\n\nPattern 4: Query Handler (Data Retrieval)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class SearchProducts(InboundPort[SearchQuery, SearchResult]):\n        async def search(self, query: SearchQuery) -&gt; SearchResult: ...\n        async def suggest(self, partial: str) -&gt; list[str]: ...\n\nPattern 5: External API Client (Third-Party Integration)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class PaymentGateway(OutboundPort[PaymentRequest, PaymentResult]):\n        async def charge(self, request: PaymentRequest) -&gt; PaymentResult: ...\n        async def refund(self, transaction_id: str) -&gt; PaymentResult: ...\n\nPattern 6: Message Broker (Async Communication)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class EventPublisher(OutboundPort[DomainEvent, None]):\n        async def publish(self, event: DomainEvent) -&gt; None: ...\n        async def publish_batch(self, events: list[DomainEvent]) -&gt; None: ...\n\nPattern 7: Notification Gateway (Multi-Channel Messaging)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    class NotificationSender(OutboundPort[Notification, bool]):\n        async def send_email(self, notification: Notification) -&gt; bool: ...\n        async def send_sms(self, notification: Notification) -&gt; bool: ...\n        async def send_push(self, notification: Notification) -&gt; bool: ...\n\nUSAGE IN DIFFERENT ARCHITECTURES\n--------------------------------\n\nThese protocols are architecture-agnostic and work in any structure:\n\n- Layered Architecture \u2014 use ports to define boundaries between layers\n- MVC Applications \u2014 define contracts between models, views, controllers\n- Microservices \u2014 define ports for service-to-service communication\n- Single-File Scripts \u2014 use ports even in simple scripts for testability\n- Domain-Driven Design \u2014 repositories and domain services as ports\n- Hexagonal / Ports-and-Adapters \u2014 a natural fit\n- Clean Architecture \u2014 ports define boundaries and dependencies\n- Your Custom Structure \u2014 no assumptions\n\nTESTING STRATEGIES\n------------------\n\nStrategy 1: In-Memory Fakes (Fast Unit Tests)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    # Production\n    repo = PostgresUserRepository(db_pool)\n\n    # Testing (no database, instant)\n    repo = InMemoryUserRepository()\n\n    # Test runs in microseconds\n    user = User(id=\"123\", email=\"test@example.com\")\n    repo.save(user)\n    assert repo.find_by_id(\"123\") == user\n\nStrategy 2: Mock Objects (Verify Interactions)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    from unittest.mock import Mock\n\n    mock_repo = Mock(spec=UserRepository)\n    mock_repo.find_by_id.return_value = User(...)\n\n    service = UserService(mock_repo)\n    service.get_user(\"123\")\n\n    mock_repo.find_by_id.assert_called_once_with(\"123\")\n\nStrategy 3: Test Doubles with State\n</code></pre> <p>.. code-block:: python</p> <pre><code>class SpyRepository:\n    def __init__(self):\n        self.saved_users = []\n        self.deleted_ids = []\n\n    def save(self, user: User) -&gt; None:\n        self.saved_users.append(user)\n\n    def delete(self, id: UserID) -&gt; bool:\n        self.deleted_ids.append(id)\n        return True\n\n# Verify behavior\nspy = SpyRepository()\nservice.register_user(spy, \"alice@example.com\", \"Alice\")\nassert len(spy.saved_users) == 1\nassert spy.saved_users[0].email == \"alice@example.com\"\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports--protocol-definitions","title":"PROTOCOL DEFINITIONS","text":"<p>See Also: - PEP 544 \u2014 Protocols: Structural subtyping (static duck typing) - typing.Protocol \u2014 Python's Protocol implementation</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.Port","title":"<code>Port</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[InputType, OutputType]</code></p> <p>Base protocol for defining interface contracts.</p> <p>Port is a generic Protocol that serves as the foundation for interface declarations. It provides type parameters (InputType, OutputType) and defines no methods \u2014 it's a marker protocol that you extend to create your own specific interfaces.</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.Port--when-to-use","title":"WHEN TO USE","text":"<ul> <li>Use <code>Port</code> directly when the Inbound/Outbound naming does not fit.</li> <li>Use <code>InboundPort</code> for operations that receive/process input.</li> <li>Use <code>OutboundPort</code> for interfaces to external systems.</li> </ul>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.Port--type-parameters","title":"TYPE PARAMETERS","text":"<ul> <li><code>InputType</code>:  the type of data accepted by operations on this interface</li> <li><code>OutputType</code>: the type of data returned by operations on this interface</li> </ul>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.Port--design-notes","title":"DESIGN NOTES","text":"<ul> <li>Marker protocol: derived protocols add whatever methods make sense.</li> <li>Structural typing (PEP 544): implementations need not inherit explicitly.</li> <li>Common ancestor for the port hierarchy.</li> </ul>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.Port--example-data-transformer","title":"EXAMPLE: DATA TRANSFORMER","text":"<p>.. code-block:: python</p> <pre><code>from building_blocks.foundation import Port\n\nclass DataTransformer(Port[SourceFormat, TargetFormat]):\n    # Transform data from one format to another.\n    def transform(self, source: SourceFormat) -&gt; TargetFormat: ...\n    def can_transform(self, source: SourceFormat) -&gt; bool: ...\n    def get_errors(self, source: SourceFormat) -&gt; list[str]: ...\n\nclass JSONToXMLTransformer:\n    def transform(self, source: dict) -&gt; str:\n        import xml.etree.ElementTree as ET\n        root = ET.Element(\"root\")\n        for key, value in source.items():\n            child = ET.SubElement(root, key)\n            child.text = str(value)\n        return ET.tostring(root, encoding=\"unicode\")\n\n    def can_transform(self, source: dict) -&gt; bool:\n        return isinstance(source, dict)\n\n    def get_errors(self, source: dict) -&gt; list[str]:\n        if not isinstance(source, dict):\n            return [\"Source must be a dictionary\"]\n        return []\n\ndef convert_data(transformer: DataTransformer[dict, str], data: dict) -&gt; str:\n    if not transformer.can_transform(data):\n        errors = transformer.get_errors(data)\n        raise ValueError(f\"Cannot transform: {errors}\")\n    return transformer.transform(data)\n</code></pre> Source code in <code>src/building_blocks/foundation/ports.py</code> <pre><code>class Port(Protocol, Generic[InputType, OutputType]):\n    \"\"\"Base protocol for defining interface contracts.\n\n    Port is a generic Protocol that serves as the foundation for interface\n    declarations. It provides type parameters (InputType, OutputType) and\n    defines no methods \u2014 it's a marker protocol that you extend to create your\n    own specific interfaces.\n\n    WHEN TO USE\n    -----------\n    - Use ``Port`` directly when the Inbound/Outbound naming does not fit.\n    - Use ``InboundPort`` for operations that receive/process input.\n    - Use ``OutboundPort`` for interfaces to external systems.\n\n    TYPE PARAMETERS\n    ---------------\n    - ``InputType``:  the type of data accepted by operations on this interface\n    - ``OutputType``: the type of data returned by operations on this interface\n\n    DESIGN NOTES\n    ------------\n    - Marker protocol: derived protocols add whatever methods make sense.\n    - Structural typing (PEP 544): implementations need not inherit explicitly.\n    - Common ancestor for the port hierarchy.\n\n    EXAMPLE: DATA TRANSFORMER\n    -------------------------\n\n    .. code-block:: python\n\n        from building_blocks.foundation import Port\n\n        class DataTransformer(Port[SourceFormat, TargetFormat]):\n            # Transform data from one format to another.\n            def transform(self, source: SourceFormat) -&gt; TargetFormat: ...\n            def can_transform(self, source: SourceFormat) -&gt; bool: ...\n            def get_errors(self, source: SourceFormat) -&gt; list[str]: ...\n\n        class JSONToXMLTransformer:\n            def transform(self, source: dict) -&gt; str:\n                import xml.etree.ElementTree as ET\n                root = ET.Element(\"root\")\n                for key, value in source.items():\n                    child = ET.SubElement(root, key)\n                    child.text = str(value)\n                return ET.tostring(root, encoding=\"unicode\")\n\n            def can_transform(self, source: dict) -&gt; bool:\n                return isinstance(source, dict)\n\n            def get_errors(self, source: dict) -&gt; list[str]:\n                if not isinstance(source, dict):\n                    return [\"Source must be a dictionary\"]\n                return []\n\n        def convert_data(transformer: DataTransformer[dict, str], data: dict) -&gt; str:\n            if not transformer.can_transform(data):\n                errors = transformer.get_errors(data)\n                raise ValueError(f\"Cannot transform: {errors}\")\n            return transformer.transform(data)\n    \"\"\"\n\n    ...\n\n    def __port_variance__(self, __x: InputType) -&gt; OutputType:\n        \"\"\"Private helper to make type variance explicit (for static checkers).\"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.Port.__port_variance__","title":"<code>__port_variance__(__x)</code>","text":"<p>Private helper to make type variance explicit (for static checkers).</p> Source code in <code>src/building_blocks/foundation/ports.py</code> <pre><code>def __port_variance__(self, __x: InputType) -&gt; OutputType:\n    \"\"\"Private helper to make type variance explicit (for static checkers).\"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.InboundPort","title":"<code>InboundPort</code>","text":"<p>               Bases: <code>Port[InputType, OutputType]</code>, <code>Protocol</code></p> <p>Protocol foundation for defining inbound operation interfaces.</p> <p><code>InboundPort</code> is intended for operations that receive input and produce output (e.g., handlers, processors, validators, use cases).</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.InboundPort--common-use-cases","title":"COMMON USE CASES","text":"<ul> <li>Request handlers (HTTP, GraphQL, gRPC)</li> <li>Command executors (CQRS commands)</li> <li>Query processors (CQRS queries)</li> <li>Data validators and processors</li> <li>Use cases / application services</li> <li>Event handlers and workflow executors</li> </ul>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.InboundPort--usage-pattern","title":"USAGE PATTERN","text":"<ol> <li>Extend <code>InboundPort</code> and define your methods.</li> <li>Implement with one or more concrete classes.</li> <li>Use as type hints in your functions.</li> <li>Swap implementations as needed (production, testing, etc.).</li> </ol>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.InboundPort--example-command-handler","title":"EXAMPLE: COMMAND HANDLER","text":"<p>.. code-block:: python</p> <pre><code>class CreateUserCommand(InboundPort[UserRegistrationData, User]):\n    def execute(self, data: UserRegistrationData) -&gt; User: ...\n    def validate(self, data: UserRegistrationData) -&gt; list[ValidationError]: ...\n\nclass CreateUserCommandHandler:\n    def __init__(self, user_repo: UserRepository, email_service: EmailService):\n        self.user_repo = user_repo\n        self.email_service = email_service\n\n    def execute(self, data: UserRegistrationData) -&gt; User:\n        errors = self.validate(data)\n        if errors:\n            raise ValidationError(errors)\n\n        if self.user_repo.find_by_email(data.email):\n            raise ValueError(\"Email already registered\")\n\n        user = User(\n            id=generate_id(),\n            email=data.email,\n            name=data.name,\n            created_at=datetime.now(),\n        )\n\n        self.user_repo.save(user)\n        self.email_service.send_welcome(user.email, user.name)\n        return user\n\n    def validate(self, data: UserRegistrationData) -&gt; list[ValidationError]:\n        errors: list[ValidationError] = []\n        if not data.email or \"@\" not in data.email:\n            errors.append(ValidationError(\"Invalid email\"))\n        if not data.name or len(data.name) &lt; 2:\n            errors.append(ValidationError(\"Name too short\"))\n        if len(data.password) &lt; 8:\n            errors.append(ValidationError(\"Password too weak\"))\n        return errors\n</code></pre> Source code in <code>src/building_blocks/foundation/ports.py</code> <pre><code>class InboundPort(Port[InputType, OutputType], Protocol):\n    \"\"\"Protocol foundation for defining inbound operation interfaces.\n\n    ``InboundPort`` is intended for operations that receive input and produce\n    output (e.g., handlers, processors, validators, use cases).\n\n    COMMON USE CASES\n    ----------------\n    - Request handlers (HTTP, GraphQL, gRPC)\n    - Command executors (CQRS commands)\n    - Query processors (CQRS queries)\n    - Data validators and processors\n    - Use cases / application services\n    - Event handlers and workflow executors\n\n    USAGE PATTERN\n    -------------\n    1. Extend ``InboundPort`` and define your methods.\n    2. Implement with one or more concrete classes.\n    3. Use as type hints in your functions.\n    4. Swap implementations as needed (production, testing, etc.).\n\n    EXAMPLE: COMMAND HANDLER\n    ------------------------\n\n    .. code-block:: python\n\n        class CreateUserCommand(InboundPort[UserRegistrationData, User]):\n            def execute(self, data: UserRegistrationData) -&gt; User: ...\n            def validate(self, data: UserRegistrationData) -&gt; list[ValidationError]: ...\n\n        class CreateUserCommandHandler:\n            def __init__(self, user_repo: UserRepository, email_service: EmailService):\n                self.user_repo = user_repo\n                self.email_service = email_service\n\n            def execute(self, data: UserRegistrationData) -&gt; User:\n                errors = self.validate(data)\n                if errors:\n                    raise ValidationError(errors)\n\n                if self.user_repo.find_by_email(data.email):\n                    raise ValueError(\"Email already registered\")\n\n                user = User(\n                    id=generate_id(),\n                    email=data.email,\n                    name=data.name,\n                    created_at=datetime.now(),\n                )\n\n                self.user_repo.save(user)\n                self.email_service.send_welcome(user.email, user.name)\n                return user\n\n            def validate(self, data: UserRegistrationData) -&gt; list[ValidationError]:\n                errors: list[ValidationError] = []\n                if not data.email or \"@\" not in data.email:\n                    errors.append(ValidationError(\"Invalid email\"))\n                if not data.name or len(data.name) &lt; 2:\n                    errors.append(ValidationError(\"Name too short\"))\n                if len(data.password) &lt; 8:\n                    errors.append(ValidationError(\"Password too weak\"))\n                return errors\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.OutboundPort","title":"<code>OutboundPort</code>","text":"<p>               Bases: <code>Port[InputType, OutputType]</code>, <code>Protocol</code></p> <p>Protocol foundation for defining outbound operation interfaces.</p> <p><code>OutboundPort</code> is intended for operations that interact with external systems, resources, or services (e.g., repositories, caches, APIs, message brokers, storage, search).</p>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.OutboundPort--common-use-cases","title":"COMMON USE CASES","text":"<ul> <li>Repositories (data persistence)</li> <li>Cache systems (fast data access)</li> <li>Message brokers (async communication)</li> <li>External API clients (third-party services)</li> <li>Email/SMS gateways (notifications)</li> <li>Search engines (full-text search)</li> <li>File storage (object storage, S3)</li> <li>Event publishers (event-driven systems)</li> <li>Logging systems (centralized logging)</li> </ul>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.OutboundPort--usage-pattern","title":"USAGE PATTERN","text":"<ol> <li>Extend <code>OutboundPort</code> and define your methods.</li> <li>Implement for different backends (SQL, NoSQL, in-memory, etc.).</li> <li>Use as type hints in your business logic.</li> <li>Swap implementations based on environment or requirements.</li> </ol>"},{"location":"reference/autodoc/foundation/ports/#building_blocks.foundation.ports.OutboundPort--example-repository-pattern","title":"EXAMPLE: REPOSITORY PATTERN","text":"<p>.. code-block:: python</p> <pre><code>class OrderRepository(OutboundPort[OrderID, Order]):\n    def find_by_id(self, id: OrderID) -&gt; Order | None: ...\n    def find_by_customer(self, customer_id: CustomerID) -&gt; list[Order]: ...\n    def find_pending(self) -&gt; list[Order]: ...\n    def save(self, order: Order) -&gt; None: ...\n    def delete(self, id: OrderID) -&gt; bool: ...\n\nclass PostgresOrderRepository:\n    def __init__(self, connection_pool):\n        self.db = connection_pool\n\n    def find_by_id(self, id: OrderID) -&gt; Order | None:\n        row = self.db.query_one(\n            \"SELECT id, customer_id, total, status, created_at FROM orders WHERE id = $1\",\n            id,\n        )\n        return Order.from_row(row) if row else None\n\n    def find_by_customer(self, customer_id: CustomerID) -&gt; list[Order]:\n        rows = self.db.query(\n            (\n                \"SELECT id, customer_id, total, status, created_at \"\n                \"FROM orders WHERE customer_id = $1 \"\n                \"ORDER BY created_at DESC\"\n            ),\n            customer_id,\n        )\n        return [Order.from_row(row) for row in rows]\n\n    def find_pending(self) -&gt; list[Order]:\n        rows = self.db.query(\n            (\n                \"SELECT id, customer_id, total, status, created_at \"\n                \"FROM orders WHERE status = 'pending' \"\n                \"ORDER BY created_at ASC\"\n            )\n        )\n        return [Order.from_row(row) for row in rows]\n\n    def save(self, order: Order) -&gt; None:\n        self.db.execute(\n            (\n                \"INSERT INTO orders (id, customer_id, total, status, created_at) \"\n                \"VALUES ($1, $2, $3, $4, $5) \"\n                \"ON CONFLICT (id) DO UPDATE \"\n                \"SET customer_id=$2, total=$3, status=$4, created_at=$5\"\n            ),\n            order.id,\n            order.customer_id,\n            order.total,\n            order.status,\n            order.created_at,\n        )\n\n    def delete(self, id: OrderID) -&gt; bool:\n        result = self.db.execute(\"DELETE FROM orders WHERE id = $1\", id)\n        return result.rowcount &gt; 0\n\ndef complete_order(repository: OrderRepository, order_id: OrderID) -&gt; Order:\n    # Mark an order as completed.\n    order = repository.find_by_id(order_id)\n    if not order:\n        raise OrderNotFound(f\"Order {order_id} not found\")\n    if order.status != \"pending\":\n        raise InvalidOperation(\"Only pending orders can be completed\")\n\n    order.status = \"completed\"\n    order.completed_at = datetime.now()\n    repository.save(order)\n    return order\n</code></pre> Source code in <code>src/building_blocks/foundation/ports.py</code> <pre><code>class OutboundPort(Port[InputType, OutputType], Protocol):\n    \"\"\"Protocol foundation for defining outbound operation interfaces.\n\n    ``OutboundPort`` is intended for operations that interact with external\n    systems, resources, or services (e.g., repositories, caches, APIs,\n    message brokers, storage, search).\n\n    COMMON USE CASES\n    ----------------\n    - Repositories (data persistence)\n    - Cache systems (fast data access)\n    - Message brokers (async communication)\n    - External API clients (third-party services)\n    - Email/SMS gateways (notifications)\n    - Search engines (full-text search)\n    - File storage (object storage, S3)\n    - Event publishers (event-driven systems)\n    - Logging systems (centralized logging)\n\n    USAGE PATTERN\n    -------------\n    1. Extend ``OutboundPort`` and define your methods.\n    2. Implement for different backends (SQL, NoSQL, in-memory, etc.).\n    3. Use as type hints in your business logic.\n    4. Swap implementations based on environment or requirements.\n\n    EXAMPLE: REPOSITORY PATTERN\n    ---------------------------\n\n    .. code-block:: python\n\n        class OrderRepository(OutboundPort[OrderID, Order]):\n            def find_by_id(self, id: OrderID) -&gt; Order | None: ...\n            def find_by_customer(self, customer_id: CustomerID) -&gt; list[Order]: ...\n            def find_pending(self) -&gt; list[Order]: ...\n            def save(self, order: Order) -&gt; None: ...\n            def delete(self, id: OrderID) -&gt; bool: ...\n\n        class PostgresOrderRepository:\n            def __init__(self, connection_pool):\n                self.db = connection_pool\n\n            def find_by_id(self, id: OrderID) -&gt; Order | None:\n                row = self.db.query_one(\n                    \"SELECT id, customer_id, total, status, created_at FROM orders WHERE id = $1\",\n                    id,\n                )\n                return Order.from_row(row) if row else None\n\n            def find_by_customer(self, customer_id: CustomerID) -&gt; list[Order]:\n                rows = self.db.query(\n                    (\n                        \"SELECT id, customer_id, total, status, created_at \"\n                        \"FROM orders WHERE customer_id = $1 \"\n                        \"ORDER BY created_at DESC\"\n                    ),\n                    customer_id,\n                )\n                return [Order.from_row(row) for row in rows]\n\n            def find_pending(self) -&gt; list[Order]:\n                rows = self.db.query(\n                    (\n                        \"SELECT id, customer_id, total, status, created_at \"\n                        \"FROM orders WHERE status = 'pending' \"\n                        \"ORDER BY created_at ASC\"\n                    )\n                )\n                return [Order.from_row(row) for row in rows]\n\n            def save(self, order: Order) -&gt; None:\n                self.db.execute(\n                    (\n                        \"INSERT INTO orders (id, customer_id, total, status, created_at) \"\n                        \"VALUES ($1, $2, $3, $4, $5) \"\n                        \"ON CONFLICT (id) DO UPDATE \"\n                        \"SET customer_id=$2, total=$3, status=$4, created_at=$5\"\n                    ),\n                    order.id,\n                    order.customer_id,\n                    order.total,\n                    order.status,\n                    order.created_at,\n                )\n\n            def delete(self, id: OrderID) -&gt; bool:\n                result = self.db.execute(\"DELETE FROM orders WHERE id = $1\", id)\n                return result.rowcount &gt; 0\n\n        def complete_order(repository: OrderRepository, order_id: OrderID) -&gt; Order:\n            # Mark an order as completed.\n            order = repository.find_by_id(order_id)\n            if not order:\n                raise OrderNotFound(f\"Order {order_id} not found\")\n            if order.status != \"pending\":\n                raise InvalidOperation(\"Only pending orders can be completed\")\n\n            order.status = \"completed\"\n            order.completed_at = datetime.now()\n            repository.save(order)\n            return order\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/result/","title":"Result","text":"<p>Result type implementation inspired by Rust's Result enum.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result","title":"<code>result</code>","text":"<p>Result type implementation inspired by Rust's Result enum.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.ResultAccessError","title":"<code>ResultAccessError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Exception raised when trying to access value or err from an inappropriate Result variant.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>class ResultAccessError(Error):\n    \"\"\"Exception raised when trying to access value or err from an inappropriate Result variant.\"\"\"\n\n    def __init__(self, message: ErrorMessage | None = None) -&gt; None:\n        if message is None:\n            message = ErrorMessage(\"Invalid access on Result type.\")\n        self._error_message = message\n        super().__init__(message)\n\n    @classmethod\n    def cannot_access_value(cls) -&gt; ResultAccessError:\n        \"\"\"Create an error for accessing value from an Err Result.\"\"\"\n        return cls(ErrorMessage(\"Cannot access value from an Err Result.\"))\n\n    @classmethod\n    def cannot_access_error(cls) -&gt; ResultAccessError:\n        \"\"\"Create an error for accessing error from an Ok Result.\"\"\"\n        return cls(ErrorMessage(\"Cannot access error from an Ok Result.\"))\n\n    @property\n    def message(self) -&gt; ErrorMessage:\n        \"\"\"Return the stored message as a string.\"\"\"\n        return self._error_message\n\n    def __str__(self) -&gt; str:\n        \"\"\"Readable string representation.\"\"\"\n        return self._error_message.value\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.ResultAccessError.message","title":"<code>message</code>  <code>property</code>","text":"<p>Return the stored message as a string.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.ResultAccessError.cannot_access_value","title":"<code>cannot_access_value()</code>  <code>classmethod</code>","text":"<p>Create an error for accessing value from an Err Result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>@classmethod\ndef cannot_access_value(cls) -&gt; ResultAccessError:\n    \"\"\"Create an error for accessing value from an Err Result.\"\"\"\n    return cls(ErrorMessage(\"Cannot access value from an Err Result.\"))\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.ResultAccessError.cannot_access_error","title":"<code>cannot_access_error()</code>  <code>classmethod</code>","text":"<p>Create an error for accessing error from an Ok Result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>@classmethod\ndef cannot_access_error(cls) -&gt; ResultAccessError:\n    \"\"\"Create an error for accessing error from an Ok Result.\"\"\"\n    return cls(ErrorMessage(\"Cannot access error from an Ok Result.\"))\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.ResultAccessError.__str__","title":"<code>__str__()</code>","text":"<p>Readable string representation.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Readable string representation.\"\"\"\n    return self._error_message.value\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Result","title":"<code>Result</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[ResultType, ErrorType]</code></p> <p>A type that represents either a success (Ok) or an error (Err).</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>class Result(Protocol, Generic[ResultType, ErrorType]):\n    \"\"\"A type that represents either a success (Ok) or an error (Err).\"\"\"\n\n    @property\n    def is_ok(self) -&gt; bool:\n        \"\"\"Guard method to check if that Result if an ok.\"\"\"\n        ...\n\n    @property\n    def is_err(self) -&gt; bool:\n        \"\"\"Guard method to check if that Result if an err.\"\"\"\n        ...\n\n    @property\n    def value(self) -&gt; ResultType | None:\n        \"\"\"Method to return the actual value.\"\"\"\n        ...\n\n    @property\n    def error(self) -&gt; ErrorType | None:\n        \"\"\"Method to return the actual error.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Result.is_ok","title":"<code>is_ok</code>  <code>property</code>","text":"<p>Guard method to check if that Result if an ok.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Result.is_err","title":"<code>is_err</code>  <code>property</code>","text":"<p>Guard method to check if that Result if an err.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Result.value","title":"<code>value</code>  <code>property</code>","text":"<p>Method to return the actual value.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Result.error","title":"<code>error</code>  <code>property</code>","text":"<p>Method to return the actual error.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok","title":"<code>Ok</code>","text":"<p>               Bases: <code>Result[ResultType, ErrorType]</code>, <code>Generic[ResultType, ErrorType]</code></p> <p>Represents a successful result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>class Ok(Result[ResultType, ErrorType], Generic[ResultType, ErrorType]):\n    \"\"\"Represents a successful result.\"\"\"\n\n    def __init__(self, value: ResultType) -&gt; None:\n        self._value = value\n\n    @property\n    def is_err(self) -&gt; bool:\n        \"\"\"Check if the result is an error.\"\"\"\n        return False\n\n    @property\n    def is_ok(self) -&gt; bool:\n        \"\"\"Check if the result is ok.\"\"\"\n        return True\n\n    @property\n    def value(self) -&gt; ResultType:\n        \"\"\"Get the successful value.\"\"\"\n        return self._value\n\n    @property\n    def error(self) -&gt; None:\n        \"\"\"Attempting to get error from an Ok result raises an error.\"\"\"\n        raise ResultAccessError.cannot_access_error()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Ok result.\"\"\"\n        return f\"Ok({self._value!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another Ok result.\"\"\"\n        return isinstance(other, Ok) and self._value == other._value\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the Ok result.\"\"\"\n        return hash(self._value)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the Ok result.\"\"\"\n        return f\"Ok({self._value})\"\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.is_err","title":"<code>is_err</code>  <code>property</code>","text":"<p>Check if the result is an error.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.is_ok","title":"<code>is_ok</code>  <code>property</code>","text":"<p>Check if the result is ok.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.value","title":"<code>value</code>  <code>property</code>","text":"<p>Get the successful value.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.error","title":"<code>error</code>  <code>property</code>","text":"<p>Attempting to get error from an Ok result raises an error.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Ok result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Ok result.\"\"\"\n    return f\"Ok({self._value!r})\"\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality with another Ok result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another Ok result.\"\"\"\n    return isinstance(other, Ok) and self._value == other._value\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the Ok result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the Ok result.\"\"\"\n    return hash(self._value)\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Ok.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the Ok result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the Ok result.\"\"\"\n    return f\"Ok({self._value})\"\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err","title":"<code>Err</code>","text":"<p>               Bases: <code>Result[ResultType, ErrorType]</code>, <code>Generic[ResultType, ErrorType]</code></p> <p>Represents an error result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>class Err(Result[ResultType, ErrorType], Generic[ResultType, ErrorType]):\n    \"\"\"Represents an error result.\"\"\"\n\n    def __init__(self, error: ErrorType) -&gt; None:\n        self._error = error\n\n    @property\n    def is_err(self) -&gt; bool:\n        \"\"\"Check if the result is an error.\"\"\"\n        return True\n\n    @property\n    def is_ok(self) -&gt; bool:\n        \"\"\"Check if the result is ok.\"\"\"\n        return False\n\n    @property\n    def value(self) -&gt; None:\n        \"\"\"Attempting to get value from an Err result raises an error.\"\"\"\n        raise ResultAccessError.cannot_access_value()\n\n    @property\n    def error(self) -&gt; ErrorType:\n        \"\"\"Get the error value.\"\"\"\n        return self._error\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Err result.\"\"\"\n        return f\"Err({self._error!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another Ok result.\"\"\"\n        return isinstance(other, Err) and self._error == other._error\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the Ok result.\"\"\"\n        return hash(self._error)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the Ok result.\"\"\"\n        return f\"Err({self._error})\"\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.is_err","title":"<code>is_err</code>  <code>property</code>","text":"<p>Check if the result is an error.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.is_ok","title":"<code>is_ok</code>  <code>property</code>","text":"<p>Check if the result is ok.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.value","title":"<code>value</code>  <code>property</code>","text":"<p>Attempting to get value from an Err result raises an error.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.error","title":"<code>error</code>  <code>property</code>","text":"<p>Get the error value.</p>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Err result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Err result.\"\"\"\n    return f\"Err({self._error!r})\"\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality with another Ok result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another Ok result.\"\"\"\n    return isinstance(other, Err) and self._error == other._error\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the Ok result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the Ok result.\"\"\"\n    return hash(self._error)\n</code></pre>"},{"location":"reference/autodoc/foundation/result/#building_blocks.foundation.result.Err.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the Ok result.</p> Source code in <code>src/building_blocks/foundation/result.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the Ok result.\"\"\"\n    return f\"Err({self._error})\"\n</code></pre>"},{"location":"reference/autodoc/foundation/result_mapper/","title":"Result Mapper","text":"<p>This module defines a Protocol/Interface for mapping Result between different layers.</p> <p>This modules defines a protocol for mapping Result types between different layers or representations.</p> <p>You can implement this protocol to create mappers that convert Result types from one form to another, facilitating data transformation across application layers.</p> <p>Example:     ApplicationResult = Result[CreateTaskResponse, CombinedValidationErrors]     HttpResult = Result[JSONResponse, ErrorResponse]</p> <pre><code>class CreateTaskHttpResultMapper(\n    ResultMapper[\n        CreateTaskResponse,\n        CombinedValidationErrors,\n        JSONResponse,\n        ErrorResponse\n    ]\n):\n    def __init__(self, success_mapper: Mapper, error_mapper: Mapper):\n        self.success_mapper = success_mapper\n        self.error_mapper = error_mapper\n\n    def map(self, result: ApplicationResult) -&gt; HttpResult:\n        if result.is_ok():\n            data = self.success_mapper.map(result.unwrap())\n            return Result.ok(data)\n        else:\n            error = self.error_mapper.map(result.unwrap_err())\n            return Result.err(error)\n</code></pre>"},{"location":"reference/autodoc/foundation/result_mapper/#building_blocks.foundation.result_mapper","title":"<code>result_mapper</code>","text":"<p>This module defines a Protocol/Interface for mapping Result between different layers.</p> <p>This modules defines a protocol for mapping Result types between different layers or representations.</p> <p>You can implement this protocol to create mappers that convert Result types from one form to another, facilitating data transformation across application layers.</p> Example <p>ApplicationResult = Result[CreateTaskResponse, CombinedValidationErrors] HttpResult = Result[JSONResponse, ErrorResponse]</p> <p>class CreateTaskHttpResultMapper(     ResultMapper[         CreateTaskResponse,         CombinedValidationErrors,         JSONResponse,         ErrorResponse     ] ):     def init(self, success_mapper: Mapper, error_mapper: Mapper):         self.success_mapper = success_mapper         self.error_mapper = error_mapper</p> <pre><code>def map(self, result: ApplicationResult) -&gt; HttpResult:\n    if result.is_ok():\n        data = self.success_mapper.map(result.unwrap())\n        return Result.ok(data)\n    else:\n        error = self.error_mapper.map(result.unwrap_err())\n        return Result.err(error)\n</code></pre>"},{"location":"reference/autodoc/foundation/result_mapper/#building_blocks.foundation.result_mapper.ResultMapper","title":"<code>ResultMapper</code>","text":"<p>               Bases: <code>Mapper[Result[SuccessInputType, ErrorInputType], Result[SuccessOutputType, ErrorOutputType]]</code>, <code>Protocol</code>, <code>Generic[SuccessInputType, ErrorInputType, SuccessOutputType, ErrorOutputType]</code></p> <p>Interface for mapping between two Result types across application layers.</p> Example <p>ApplicationResult = Result[CreateTaskResponse, CombinedValidationErrors] HttpResult = Result[JSONResponse, ErrorResponse]</p> <p>class CreateTaskHttpResultMapper(     ResultMapper[         CreateTaskResponse,         CombinedValidationErrors,         JSONResponse,         ErrorResponse     ] ):     def init(self, success_mapper: Mapper, error_mapper: Mapper):         self.success_mapper = success_mapper         self.error_mapper = error_mapper</p> <pre><code>def map(self, result: ApplicationResult) -&gt; HttpResult:\n    if result.is_ok():\n        data = self.success_mapper.map(result.unwrap())\n        return Result.ok(data)\n    else:\n        error = self.error_mapper.map(result.unwrap_err())\n        return Result.err(error)\n</code></pre> Source code in <code>src/building_blocks/foundation/result_mapper.py</code> <pre><code>class ResultMapper(\n    Mapper[\n        Result[SuccessInputType, ErrorInputType],\n        Result[SuccessOutputType, ErrorOutputType],\n    ],\n    Protocol,\n    Generic[SuccessInputType, ErrorInputType, SuccessOutputType, ErrorOutputType],\n):\n    \"\"\"Interface for mapping between two Result types across application layers.\n\n    Example:\n        ApplicationResult = Result[CreateTaskResponse, CombinedValidationErrors]\n        HttpResult = Result[JSONResponse, ErrorResponse]\n\n        class CreateTaskHttpResultMapper(\n            ResultMapper[\n                CreateTaskResponse,\n                CombinedValidationErrors,\n                JSONResponse,\n                ErrorResponse\n            ]\n        ):\n            def __init__(self, success_mapper: Mapper, error_mapper: Mapper):\n                self.success_mapper = success_mapper\n                self.error_mapper = error_mapper\n\n            def map(self, result: ApplicationResult) -&gt; HttpResult:\n                if result.is_ok():\n                    data = self.success_mapper.map(result.unwrap())\n                    return Result.ok(data)\n                else:\n                    error = self.error_mapper.map(result.unwrap_err())\n                    return Result.err(error)\n    \"\"\"\n\n    ...\n\n    def map(\n        self, result: Result[SuccessInputType, ErrorInputType]\n    ) -&gt; Result[SuccessOutputType, ErrorOutputType]:\n        \"\"\"Map a Result from one representation to another.\n\n        Args:\n            result: The input Result to be mapped from one type to another.\n\n        Returns:\n            The mapped Result with transformed success and error types.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/autodoc/foundation/result_mapper/#building_blocks.foundation.result_mapper.ResultMapper.map","title":"<code>map(result)</code>","text":"<p>Map a Result from one representation to another.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Result[SuccessInputType, ErrorInputType]</code> <p>The input Result to be mapped from one type to another.</p> required <p>Returns:</p> Type Description <code>Result[SuccessOutputType, ErrorOutputType]</code> <p>The mapped Result with transformed success and error types.</p> Source code in <code>src/building_blocks/foundation/result_mapper.py</code> <pre><code>def map(\n    self, result: Result[SuccessInputType, ErrorInputType]\n) -&gt; Result[SuccessOutputType, ErrorOutputType]:\n    \"\"\"Map a Result from one representation to another.\n\n    Args:\n        result: The input Result to be mapped from one type to another.\n\n    Returns:\n        The mapped Result with transformed success and error types.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/","title":"Base","text":"<p>This module provides the foundational error classes used across the Building Blocks framework.</p> <p>It defines structured, debuggable, and composable error types that can be raised, caught, and combined in a uniform way throughout all architectural layers.</p>"},{"location":"reference/autodoc/foundation/errors/base/#classes","title":"Classes","text":"<p>Error:     Base class for all structured errors in the system. Inherits from     <code>Exception</code> and <code>Debuggable</code>, allowing it to be raised and logged like     a standard exception while carrying structured metadata.</p> <p>NoneNotAllowedError     Specialized <code>Error</code> indicating that a <code>None</code> value was provided where it     is not allowed.</p> <p>FieldErrors     Represents validation or constraint errors associated with a single field.     Provides iterable access to individual <code>Error</code> instances for that field.</p> <p>CombinedErrors     Aggregates multiple <code>Error</code> (or subclass) instances into one. Useful for     collecting and raising multiple failures together (e.g., validation errors).</p>"},{"location":"reference/autodoc/foundation/errors/base/#notes","title":"Notes:","text":"<ul> <li>All errors defined here are part of the foundation module and can be   safely reused by higher components present in layer, if you have layer defined.</li> <li>Each error supports a detailed <code>as_debug_string()</code> method for rich diagnostic output.</li> </ul>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base","title":"<code>base</code>","text":"<p>This module provides the foundational error classes used across the Building Blocks framework.</p> <p>It defines structured, debuggable, and composable error types that can be raised, caught, and combined in a uniform way throughout all architectural layers.</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base--classes","title":"Classes","text":"Error <p>Base class for all structured errors in the system. Inherits from <code>Exception</code> and <code>Debuggable</code>, allowing it to be raised and logged like a standard exception while carrying structured metadata.</p> <p>NoneNotAllowedError     Specialized <code>Error</code> indicating that a <code>None</code> value was provided where it     is not allowed.</p> <p>FieldErrors     Represents validation or constraint errors associated with a single field.     Provides iterable access to individual <code>Error</code> instances for that field.</p> <p>CombinedErrors     Aggregates multiple <code>Error</code> (or subclass) instances into one. Useful for     collecting and raising multiple failures together (e.g., validation errors).</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base--notes","title":"Notes:","text":"<ul> <li>All errors defined here are part of the foundation module and can be   safely reused by higher components present in layer, if you have layer defined.</li> <li>Each error supports a detailed <code>as_debug_string()</code> method for rich diagnostic output.</li> </ul>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code>, <code>Debuggable</code></p> <p>Base class for all structured errors that can be raised like standard Exceptions.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>class Error(Exception, Debuggable):\n    \"\"\"Base class for all structured errors that can be raised like standard Exceptions.\"\"\"\n\n    def __init__(self, message: ErrorMessage, metadata: ErrorMetadata | None = None) -&gt; None:\n        super().__init__(message.value)\n        self._message = message\n        self._metadata = metadata or ErrorMetadata(context={})\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;{self.__class__.__name__} message={self._message.value!r} \"\n            f\"context={self._metadata.context!r}&gt;\"\n        )\n\n    def __str__(self) -&gt; str:\n        context_str = f\" | Context: {self._metadata.context}\" if self._metadata.context else \"\"\n        return f\"{self.__class__.__name__}: {self._message.value}{context_str}\"\n\n    @property\n    def message(self) -&gt; ErrorMessage:\n        \"\"\"Structured error message.\"\"\"\n        return self._message\n\n    @property\n    def metadata(self) -&gt; ErrorMetadata:\n        \"\"\"Structured metadata with additional context.\"\"\"\n        return self._metadata\n\n    @property\n    def context(self) -&gt; dict[str, Any]:\n        \"\"\"Shortcut for accessing the metadata context.\"\"\"\n        return self._metadata.context\n\n    def as_debug_string(self) -&gt; str:\n        \"\"\"Return a detailed, multi-line string for debugging.\"\"\"\n        return (\n            f\"{self.__class__.__name__}(\\n\"\n            f\"  message={repr(self._message)},\\n\"\n            f\"  metadata={repr(self._metadata)}\\n\"\n            \")\"\n        )\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.Error.message","title":"<code>message</code>  <code>property</code>","text":"<p>Structured error message.</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.Error.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Structured metadata with additional context.</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.Error.context","title":"<code>context</code>  <code>property</code>","text":"<p>Shortcut for accessing the metadata context.</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.Error.as_debug_string","title":"<code>as_debug_string()</code>","text":"<p>Return a detailed, multi-line string for debugging.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def as_debug_string(self) -&gt; str:\n    \"\"\"Return a detailed, multi-line string for debugging.\"\"\"\n    return (\n        f\"{self.__class__.__name__}(\\n\"\n        f\"  message={repr(self._message)},\\n\"\n        f\"  metadata={repr(self._metadata)}\\n\"\n        \")\"\n    )\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.NoneNotAllowedError","title":"<code>NoneNotAllowedError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Error indicating that a None value was provided where it is not allowed.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>class NoneNotAllowedError(Error):\n    \"\"\"Error indicating that a None value was provided where it is not allowed.\"\"\"\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors","title":"<code>FieldErrors</code>","text":"<p>               Bases: <code>Error</code></p> <p>Base class for errors associated with a specific field.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>class FieldErrors(Error):\n    \"\"\"Base class for errors associated with a specific field.\"\"\"\n\n    def __init__(self, field: FieldReference, errors: Iterable[Error]) -&gt; None:\n        self._field = field\n        self._errors: Sequence[Error] = tuple(\n            errors,\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a concise string representation of the field errors.\"\"\"\n        return (\n            f\"&lt;{self._get_title_prefix()} field={self._field.value!r} \"\n            f\"errors={len(self._errors)}&gt;\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a human-readable string representation of the field errors.\"\"\"\n        error_messages = \"\\n\".join(f\" - {str(error)}\" for error in self._errors)\n        return f\"{self._get_title_prefix()} for field '{self._field.value}':\\n\" f\"{error_messages}\"\n\n    def __iter__(self) -&gt; Iterator[Error]:\n        \"\"\"Iterate over the errors associated with the field.\"\"\"\n        return iter(self._errors)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of errors associated with the field.\"\"\"\n        return len(self._errors)\n\n    @property\n    def field(self) -&gt; FieldReference:\n        \"\"\"The field associated with these errors.\"\"\"\n        return self._field\n\n    @property\n    def errors(self) -&gt; Sequence[Error]:\n        \"\"\"The collection of errors associated with the field.\"\"\"\n        return self._errors\n\n    def as_debug_string(self) -&gt; str:\n        \"\"\"Return detailed, multi-line string of this field error collection for debugging.\"\"\"\n        error_strings = [f\"    {err.as_debug_string()}\" for err in self._errors]\n        return (\n            f\"{self._get_title_prefix()}(\\n\"\n            f\"  field={repr(self._field)},\\n\"\n            f\"  errors=[\\n\"\n            + (\"\" if not error_strings else \"\\n\".join(error_strings) + \"\\n\")\n            + \"  ]\\n\"\n            \")\"\n        )\n\n    def _get_title_prefix(self) -&gt; str:\n        \"\"\"Get the title prefix for this field error type.\"\"\"\n        return self.__class__.__name__\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors.field","title":"<code>field</code>  <code>property</code>","text":"<p>The field associated with these errors.</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors.errors","title":"<code>errors</code>  <code>property</code>","text":"<p>The collection of errors associated with the field.</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation of the field errors.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise string representation of the field errors.\"\"\"\n    return (\n        f\"&lt;{self._get_title_prefix()} field={self._field.value!r} \"\n        f\"errors={len(self._errors)}&gt;\"\n    )\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors.__str__","title":"<code>__str__()</code>","text":"<p>Return a human-readable string representation of the field errors.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a human-readable string representation of the field errors.\"\"\"\n    error_messages = \"\\n\".join(f\" - {str(error)}\" for error in self._errors)\n    return f\"{self._get_title_prefix()} for field '{self._field.value}':\\n\" f\"{error_messages}\"\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the errors associated with the field.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Error]:\n    \"\"\"Iterate over the errors associated with the field.\"\"\"\n    return iter(self._errors)\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of errors associated with the field.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of errors associated with the field.\"\"\"\n    return len(self._errors)\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.FieldErrors.as_debug_string","title":"<code>as_debug_string()</code>","text":"<p>Return detailed, multi-line string of this field error collection for debugging.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def as_debug_string(self) -&gt; str:\n    \"\"\"Return detailed, multi-line string of this field error collection for debugging.\"\"\"\n    error_strings = [f\"    {err.as_debug_string()}\" for err in self._errors]\n    return (\n        f\"{self._get_title_prefix()}(\\n\"\n        f\"  field={repr(self._field)},\\n\"\n        f\"  errors=[\\n\"\n        + (\"\" if not error_strings else \"\\n\".join(error_strings) + \"\\n\")\n        + \"  ]\\n\"\n        \")\"\n    )\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.CombinedErrors","title":"<code>CombinedErrors</code>","text":"<p>               Bases: <code>Error</code>, <code>Generic[ErrorType]</code></p> <p>Base class for combining multiple errors into one.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>class CombinedErrors(Error, Generic[ErrorType]):\n    \"\"\"Base class for combining multiple errors into one.\"\"\"\n\n    def __init__(self, errors: Iterable[ErrorType]) -&gt; None:\n        self._errors: Sequence[ErrorType] = tuple(errors)\n        combined_message = f\"{len(self._errors)} errors occurred.\"\n        super().__init__(message=ErrorMessage(combined_message))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a concise string representation of the combined errors.\"\"\"\n        return f\"&lt;{self._get_title_prefix()} errors={len(self._errors)}&gt;\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a human-readable string representation of the combined errors.\"\"\"\n        error_details = \"\\n\".join(f\"- {str(error)}\" for error in self._errors)\n        return f\"{self._get_title_prefix()}:\\n{error_details}\"\n\n    @property\n    def errors(self) -&gt; Sequence[ErrorType]:\n        \"\"\"The collection of combined errors.\"\"\"\n        return self._errors\n\n    def as_debug_string(self) -&gt; str:\n        \"\"\"Return a detailed, multi-line string for debugging, showing all contained errors.\"\"\"\n        error_strings = [\n            f\"    {e.as_debug_string().replace(chr(10), chr(10)+'    ')}\" for e in self._errors\n        ]\n        return (\n            f\"{self._get_title_prefix()}(\\n\"\n            f\"  errors=[\\n\"\n            + (\"\" if not error_strings else \"\\n\".join(error_strings) + \"\\n\")\n            + \"  ]\\n\"\n            \")\"\n        )\n\n    def __iter__(self) -&gt; Iterator[ErrorType]:\n        \"\"\"Iterate over the combined errors.\"\"\"\n        return iter(self._errors)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of combined errors.\"\"\"\n        return len(self._errors)\n\n    def _get_title_prefix(self) -&gt; str:\n        \"\"\"Get the title prefix for this combined error type.\"\"\"\n        return self.__class__.__name__\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.CombinedErrors.errors","title":"<code>errors</code>  <code>property</code>","text":"<p>The collection of combined errors.</p>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.CombinedErrors.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation of the combined errors.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise string representation of the combined errors.\"\"\"\n    return f\"&lt;{self._get_title_prefix()} errors={len(self._errors)}&gt;\"\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.CombinedErrors.__str__","title":"<code>__str__()</code>","text":"<p>Return a human-readable string representation of the combined errors.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a human-readable string representation of the combined errors.\"\"\"\n    error_details = \"\\n\".join(f\"- {str(error)}\" for error in self._errors)\n    return f\"{self._get_title_prefix()}:\\n{error_details}\"\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.CombinedErrors.as_debug_string","title":"<code>as_debug_string()</code>","text":"<p>Return a detailed, multi-line string for debugging, showing all contained errors.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def as_debug_string(self) -&gt; str:\n    \"\"\"Return a detailed, multi-line string for debugging, showing all contained errors.\"\"\"\n    error_strings = [\n        f\"    {e.as_debug_string().replace(chr(10), chr(10)+'    ')}\" for e in self._errors\n    ]\n    return (\n        f\"{self._get_title_prefix()}(\\n\"\n        f\"  errors=[\\n\"\n        + (\"\" if not error_strings else \"\\n\".join(error_strings) + \"\\n\")\n        + \"  ]\\n\"\n        \")\"\n    )\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.CombinedErrors.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the combined errors.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __iter__(self) -&gt; Iterator[ErrorType]:\n    \"\"\"Iterate over the combined errors.\"\"\"\n    return iter(self._errors)\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/base/#building_blocks.foundation.errors.base.CombinedErrors.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of combined errors.</p> Source code in <code>src/building_blocks/foundation/errors/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of combined errors.\"\"\"\n    return len(self._errors)\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/cant_modify_immutable_attribute_error/","title":"Cant Modify Immutable Attribute Error","text":"<p>Module for CantModifyImmutableAttributeError exception.</p>"},{"location":"reference/autodoc/foundation/errors/cant_modify_immutable_attribute_error/#building_blocks.foundation.errors.cant_modify_immutable_attribute_error","title":"<code>cant_modify_immutable_attribute_error</code>","text":"<p>Module for CantModifyImmutableAttributeError exception.</p>"},{"location":"reference/autodoc/foundation/errors/cant_modify_immutable_attribute_error/#building_blocks.foundation.errors.cant_modify_immutable_attribute_error.CantModifyImmutableAttributeError","title":"<code>CantModifyImmutableAttributeError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Raised when there is an attempt to modify an immutable attribute of an object.</p> Source code in <code>src/building_blocks/foundation/errors/cant_modify_immutable_attribute_error.py</code> <pre><code>class CantModifyImmutableAttributeError(Error):\n    \"\"\"Raised when there is an attempt to modify an immutable attribute of an object.\"\"\"\n\n    def __init__(self, class_name: str, attribute_name: str):\n        message = ErrorMessage(\n            f\"Cannot modify immutable attribute '{attribute_name}' of class '{class_name}'.\"\n        )\n        metadata = ErrorMetadata(\n            {\n                \"class_name\": class_name,\n                \"attribute_name\": attribute_name,\n            }\n        )\n        super().__init__(message, metadata)\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/core/","title":"Core","text":"<p>Core error components for the building blocks foundation.</p> <p>Defines fundamental data structures for error messages, metadata, and field references.</p>"},{"location":"reference/autodoc/foundation/errors/core/#building_blocks.foundation.errors.core","title":"<code>core</code>","text":"<p>Core error components for the building blocks foundation.</p> <p>Defines fundamental data structures for error messages, metadata, and field references.</p>"},{"location":"reference/autodoc/foundation/errors/core/#building_blocks.foundation.errors.core.ErrorMessage","title":"<code>ErrorMessage</code>  <code>dataclass</code>","text":"<p>Represents an immutable error message component.</p> Source code in <code>src/building_blocks/foundation/errors/core.py</code> <pre><code>@dataclass(frozen=True)\nclass ErrorMessage:\n    \"\"\"Represents an immutable error message component.\"\"\"\n\n    value: str\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/core/#building_blocks.foundation.errors.core.ErrorMetadata","title":"<code>ErrorMetadata</code>  <code>dataclass</code>","text":"<p>Represents metadata about the error.</p> Source code in <code>src/building_blocks/foundation/errors/core.py</code> <pre><code>@dataclass(frozen=True)\nclass ErrorMetadata:\n    \"\"\"Represents metadata about the error.\"\"\"\n\n    context: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/core/#building_blocks.foundation.errors.core.FieldReference","title":"<code>FieldReference</code>  <code>dataclass</code>","text":"<p>Represents a reference to a field in the error message.</p> Source code in <code>src/building_blocks/foundation/errors/core.py</code> <pre><code>@dataclass(frozen=True)\nclass FieldReference:\n    \"\"\"Represents a reference to a field in the error message.\"\"\"\n\n    value: str\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/rule_violation_error/","title":"Rule Violation Error","text":"<p>Module defining errors related to rule violations within the system.</p> <p>Defines error classes for handling rule violation scenarios.</p>"},{"location":"reference/autodoc/foundation/errors/rule_violation_error/#building_blocks.foundation.errors.rule_violation_error","title":"<code>rule_violation_error</code>","text":"<p>Module defining errors related to rule violations within the system.</p> <p>Defines error classes for handling rule violation scenarios.</p>"},{"location":"reference/autodoc/foundation/errors/rule_violation_error/#building_blocks.foundation.errors.rule_violation_error.RuleViolationError","title":"<code>RuleViolationError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Base class for rule violation errors.</p> Source code in <code>src/building_blocks/foundation/errors/rule_violation_error.py</code> <pre><code>class RuleViolationError(Error):\n    \"\"\"Base class for rule violation errors.\"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/rule_violation_error/#building_blocks.foundation.errors.rule_violation_error.CombinedRuleViolationErrors","title":"<code>CombinedRuleViolationErrors</code>","text":"<p>               Bases: <code>CombinedErrors[RuleViolationError]</code></p> <p>Aggregates multiple rule violation errors for easier handling and reporting.</p> Source code in <code>src/building_blocks/foundation/errors/rule_violation_error.py</code> <pre><code>class CombinedRuleViolationErrors(CombinedErrors[RuleViolationError]):\n    \"\"\"Aggregates multiple rule violation errors for easier handling and reporting.\"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/validation_error/","title":"Validation Error","text":"<p>Modules defining validation error classes.</p> <p>Defines error classes related to validation failures within the system.</p>"},{"location":"reference/autodoc/foundation/errors/validation_error/#building_blocks.foundation.errors.validation_error","title":"<code>validation_error</code>","text":"<p>Modules defining validation error classes.</p> <p>Defines error classes related to validation failures within the system.</p>"},{"location":"reference/autodoc/foundation/errors/validation_error/#building_blocks.foundation.errors.validation_error.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Base class for validation errors.</p> Source code in <code>src/building_blocks/foundation/errors/validation_error.py</code> <pre><code>class ValidationError(Error):\n    \"\"\"Base class for validation errors.\"\"\"\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/validation_error/#building_blocks.foundation.errors.validation_error.ValidationFieldErrors","title":"<code>ValidationFieldErrors</code>","text":"<p>               Bases: <code>FieldErrors</code></p> <p>Validation errors associated with a specific field.</p> Source code in <code>src/building_blocks/foundation/errors/validation_error.py</code> <pre><code>class ValidationFieldErrors(FieldErrors):\n    \"\"\"Validation errors associated with a specific field.\"\"\"\n</code></pre>"},{"location":"reference/autodoc/foundation/errors/validation_error/#building_blocks.foundation.errors.validation_error.CombinedValidationErrors","title":"<code>CombinedValidationErrors</code>","text":"<p>               Bases: <code>CombinedErrors[ValidationFieldErrors]</code></p> <p>Aggregates multiple validation errors for easier handling and reporting.</p> Source code in <code>src/building_blocks/foundation/errors/validation_error.py</code> <pre><code>class CombinedValidationErrors(CombinedErrors[ValidationFieldErrors]):\n    \"\"\"Aggregates multiple validation errors for easier handling and reporting.\"\"\"\n</code></pre>"},{"location":"reference/autodoc/foundation/meta/final_meta/","title":"Final Meta","text":"<p>FinalMeta and runtime_final decorators.</p> <p>This module provides runtime enforcement for methods marked as <code>@runtime_final</code>. It complements the static <code>@final</code> decorator from <code>typing</code> by preventing subclasses from overriding these methods at runtime.</p>"},{"location":"reference/autodoc/foundation/meta/final_meta/#building_blocks.foundation.meta.final_meta","title":"<code>final_meta</code>","text":"<p>FinalMeta and runtime_final decorators.</p> <p>This module provides runtime enforcement for methods marked as <code>@runtime_final</code>. It complements the static <code>@final</code> decorator from <code>typing</code> by preventing subclasses from overriding these methods at runtime.</p>"},{"location":"reference/autodoc/foundation/meta/final_meta/#building_blocks.foundation.meta.final_meta.FinalMeta","title":"<code>FinalMeta</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass that enforces runtime immutability of methods marked as <code>@runtime_final</code>.</p> <p>Any attempt to override a <code>@runtime_final</code> method in a subclass raises <code>TypeError</code> at class creation time.</p> Source code in <code>src/building_blocks/foundation/meta/final_meta.py</code> <pre><code>class FinalMeta(type):\n    \"\"\"Metaclass that enforces runtime immutability of methods marked as `@runtime_final`.\n\n    Any attempt to override a `@runtime_final` method in a subclass raises `TypeError`\n    at class creation time.\n    \"\"\"\n\n    def __new__(\n        mcls: Type[type],\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwargs: Any,\n    ) -&gt; type:\n        \"\"\"Prevent overriding of runtime-final methods in subclasses.\"\"\"\n        # Collect all runtime-final methods from base classes and their ancestors\n        final_methods: set[str] = {\n            attr_name\n            for base in bases\n            for cls in base.__mro__  # Walk the entire inheritance chain\n            for attr_name, attr_value in cls.__dict__.items()\n            if getattr(attr_value, \"__is_runtime_final__\", False)\n        }\n\n        # Check for any forbidden overrides in the subclass namespace\n        for method_name in final_methods:\n            if method_name in namespace:\n                raise TypeError(\n                    f\"Cannot override runtime-final method '{method_name}' in subclass '{name}'.\"\n                )\n\n        return type.__new__(mcls, name, bases, namespace)\n</code></pre>"},{"location":"reference/autodoc/foundation/meta/final_meta/#building_blocks.foundation.meta.final_meta.FinalMeta.__new__","title":"<code>__new__(mcls, name, bases, namespace, **kwargs)</code>","text":"<p>Prevent overriding of runtime-final methods in subclasses.</p> Source code in <code>src/building_blocks/foundation/meta/final_meta.py</code> <pre><code>def __new__(\n    mcls: Type[type],\n    name: str,\n    bases: tuple[type, ...],\n    namespace: dict[str, Any],\n    **kwargs: Any,\n) -&gt; type:\n    \"\"\"Prevent overriding of runtime-final methods in subclasses.\"\"\"\n    # Collect all runtime-final methods from base classes and their ancestors\n    final_methods: set[str] = {\n        attr_name\n        for base in bases\n        for cls in base.__mro__  # Walk the entire inheritance chain\n        for attr_name, attr_value in cls.__dict__.items()\n        if getattr(attr_value, \"__is_runtime_final__\", False)\n    }\n\n    # Check for any forbidden overrides in the subclass namespace\n    for method_name in final_methods:\n        if method_name in namespace:\n            raise TypeError(\n                f\"Cannot override runtime-final method '{method_name}' in subclass '{name}'.\"\n            )\n\n    return type.__new__(mcls, name, bases, namespace)\n</code></pre>"},{"location":"reference/autodoc/foundation/meta/final_meta/#building_blocks.foundation.meta.final_meta.runtime_final","title":"<code>runtime_final(func)</code>","text":"<p>Decorator that marks a method as runtime-final and type-hint final.</p> <p>Adds both static (<code>__final__</code>) and runtime (<code>__is_runtime_final__</code>) flags.</p> Source code in <code>src/building_blocks/foundation/meta/final_meta.py</code> <pre><code>def runtime_final(func: F) -&gt; F:\n    \"\"\"Decorator that marks a method as runtime-final and type-hint final.\n\n    Adds both static (`__final__`) and runtime (`__is_runtime_final__`) flags.\n    \"\"\"\n    func.__final__ = True  # type: ignore[attr-defined]\n    func.__is_runtime_final__ = True  # type: ignore[attr-defined]\n    return func\n</code></pre>"}]}